<?xml version="1.0" encoding="UTF-8"?>
<processinginstructions xmlns="http://thermal.cnde.iastate.edu/datacollect/processinginstructions" xmlns:prx="http://thermal.cnde.iastate.edu/datacollect/processinginstructions" xmlns:dcv="http://thermal.cnde.iastate.edu/dcvalue" xmlns:xlink="http://www.w3.org/1999/xlink">
  <!-- Idea: Address inability to deal with multiple coupled experiment logs
       by being able to put inputfiles into different classes (class 
       attribute). Then in the elementmatch you can select which experiment 
       log to operate on with a class attribute there. -->
       

  <inputfile xlink:href="example_input.xlg"/>
  <outputfile xlink:href="example_input.xlp"/> <!-- if outputfile tag is omitted and input name ends with .xlg, outputfile defaults to original with extension changed to .xlp -->
  <inputfilter xlink:href="filterscript" param1="-a" param2="-b"> <!-- inputfilter is what is used to make initial conversion of inputfile to outputfile. It is run as a command with the specified parameters followed by the path to the input file and the path to the output file -->
    
  <hostname>pequod</hostname>  <!-- if specified, will only run on this hostname to prevent conflicts when file locking does not operate across hosts -->
  <elementmatch>xpath_condition</elementmatch>
  <step name="pullparams" descr="Pull in parameters from other files">
    <!-- Note: if you don't provide a step name, it uses the script name, 
	 with extension and path removed -->
    <script xlink:href="pullparams.py" function="run">     <!-- Note: You can explicitly specify the function to run (default is "rununlocked" or "run". If the name ends with "unlocked" then the function will be run with the xlp file unlocked.  You can reference an explicit path, by specifying the script with xlink:href, or  ask dc_process to search its script path by using "name" to specify the script. -->
      <elementmatch>xpath_condition_override</elementmatch>
      <parameter name="foo">
	<!-- Can supply a condition. It is an xpath, evaluated in the context of the node 
             we are operating on. Two variables are supplied: $filepath:   path to .xlp file
             and $filename: filename portion of xlp file -->
        <!-- The way this works is you provide multiple value tags with different conditions
             and they are tested in order -->
	<numvalue condition="$filename='example_input_1.xlp'" dcv:units="kHz">34.5</numvalue>
      </parameter>
      <parameter name="bar">
	<strvalue>BAR</strvalue>
      </parameter>
      <parameter name="fubar"> 
	<xpath>foo/bar/fubar[@foo="bar"]</xpath> <!-- xpaths are relative to the current node as context node -->
      </parameter>
      <!-- in addition, if the Python or Matlab script has additional 
      named parameters beyond the ones listed here, those parameter
      names should start with a prefix (must be one of the xmlns 
      prefixes above) followed by an underscore followed by a tag name, 
      and the parameter will automatically be provided with the tag
      content. 

      In Python, this means the element itself. In Matlab this means
      a string representation.

      In Python, automatic parameters with the textual value of an element
      can be generated by appending "_text" to the parameter name. 
      Likewise, automatic parameters with the dc_value.hrefvalue of an element
      can be generated by appending "_href" to the parameter name, and
      automatic parameters with the hrefvalue of an element converted to
      a complete path can be generated by appending "_hreffullpath" to
      the parameter name

      -->
    </script>
  </step>
  <!-- Idea: You can make a step operate on all input files together by 
       putting a <multifile/> tag in the step tag, e.g. -->
  <step name="multifile">
    <inputfileset/>
    <!-- the input files are assembled into a db:dir with db:file elements -->
    <!-- NOTE: This will probably not be implemented soon -->
    <elementmatch>db:file[@basename='filename']/filemaintag</elementmatch>

    <script><pycode><![CDATA[
def run(_xmldoc):
    pass

]]></pycode></script>

  </step>
  
</processinginstructions>
