#! /bin/env python
from __future__ import print_function

import sys

orig_sys_exit=sys.exit # keep a copy of real sys.exit, because ipython messes it up

# set up stdout/stderr forwarders as FIRST step before other modules get loaded
class stdiohandler(object):
    orig=None  # original handle to forward to 
    encoding=None
    closed=False
    errors=None
    fileno=None
    isatty=None
    mode=None
    name=None
    newlines=None
    seek=None
    softspace=None
    tell=None
    flush=None
    truncate=None
    readlines=None
    readline=None

    def write(self,text):
        self.orig.write(text)
        if self.dest is not None:
            self.dest.write(text)
            pass
        
        pass

    def writeline(self,iterable):
        for entry in iterable:
            self.write(entry)
            pass

        pass
    def set_dest(self,dest):
        self.dest=dest
        pass

    def __init__(self,orig,dest):
        self.orig=orig
        self.dest=dest
        self.encoding=orig.encoding
        self.errors=orig.errors
        self.fileno=orig.fileno
        self.isatty=orig.isatty
        self.mode=orig.mode
        self.name=orig.name
        self.newlines=orig.newlines
        self.seek=orig.seek
        if hasattr(orig,"softspace"): # not present in python3
            self.softspace=orig.softspace
            pass
        
        self.tell=orig.tell
        self.flush=orig.flush
        self.truncate=orig.truncate
        self.readlines=orig.readlines
        self.readline=orig.readline
        pass
    pass

stdouthandler=stdiohandler(sys.stdout,None)
sys.stdout=stdouthandler

stderrhandler=stdiohandler(sys.stderr,None)
sys.stderr=stderrhandler

import os
import os.path
import posixpath
import socket
import copy
import inspect
import numbers
import traceback
import collections
import ast
from pkg_resources import resource_string
from lxml import etree

try:
    from cStringIO import StringIO
    pass
except ImportError:
    from io import StringIO
    pass

if "--gtk3" in sys.argv or sys.version_info[0] >= 3:  # gtk3
    import gi
    gi.require_version('Gtk','3.0')
    from gi.repository import Gtk as gtk
    pass
else :  # gtk2
    import gobject
    import gtk
    pass

import shutil
import datetime
import subprocess

try:
    # py2.x
    from urllib import pathname2url
    from urllib import url2pathname
    from urllib import quote
    from urllib import unquote
    from urlparse import urlparse
    from urlparse import urlunparse
    from urlparse import urljoin    
    pass
except ImportError:
    # py3.x
    from urllib.request import pathname2url
    from urllib.request import url2pathname
    from urllib.parse import quote
    from urllib.parse import unquote
    from urllib.parse import urlparse
    from urllib.parse import urlunparse
    from urllib.parse import urljoin
    pass

import dg_units
dg_units.units_config("insert_basic_units")
import dg_timestamp
from datacollect2 import canonicalize_path
from datacollect2.canonicalize_path import etxpath2human

#class dummy(object):
#    pass

## trace symbolic link to find installed directory
#thisfile=sys.modules[dummy.__module__].__file__
#if os.path.islink(thisfile):
#    installedfile=os.readlink(thisfile)
#    if not os.path.isabs(installedfile):
#        installedfile=os.path.join(os.path.dirname(thisfile),installedfile)
#        pass
#    pass
#else:
#    installedfile=thisfile
#    pass
#
#installeddir=os.path.dirname(installedfile)
#
#if os.path.exists(os.path.join(installeddir,"../lib/checklist.py")):
#    installeddir=os.path.join(installeddir,"../")
#    pass
#elif os.path.exists(os.path.join(installeddir,"../gui2/lib/checklist.py")):
#    installeddir=os.path.join(installeddir,"../gui2")
#    pass
#
#sys.path.append(installeddir)
#sys.path.append(os.path.join(installeddir,"lib/"))

from datacollect2 import dc_value as dcv
from datacollect2 import dc_provenance as provenance
from datacollect2 import xmldoc
from datacollect2 import dc_process_common


# Concept
# 1. Merge xmlfilter functionality into xmldoc functionality. 
#    a. Ability to define filters that can be executed
#    b. Filter must say what elements it operates on
#    c. Must be possible to further restrict which element is operated
#    d. Filter must overwrite pre-existing output
#    e. Filter must log provenance. 
#    f. Must lock output file to prevent conflicts by multiple simultaneous
#       scripts
#
#    g. Filters are defined by ".prx" files. See ../doc/prxexample.prx
#
#    h. Processing instructions are defined by an ordered list of filters
#    i. To run a filter, it must be on the list in the prx file as a "step"
#    j. A filter can be run with additional constraints so that it only 
#       operates on a subset of the usual tags. (see the -f option, below)
#    k. As the filter executes,  all elements referenced and all elements
#       created/modified are tracked so the former can be listed as 
#       <dcp:used> in the <dcp:process> domain and the latter can reference
#       the <dcp:process> domain by uuid. 
#    l. The execution of the filter creates a new <dcp:process> domain within
#       the <dcp:process> domain for the execution of the dc_process program.
#       Additional sub-process domains are created for each element processed
#       by the filter. 
#    m. Once file locking support is implemented in xmldoc, critical regions
#       are defined here, and element persistence across critical regions is 
#       eliminated, it should be possible to have multiple processes running
#       simultaneously on the same file!


outputnsmap={
    "dcp": "http://thermal.cnde.iastate.edu/datacollect/provenance",
    }


try: 
    __install_prefix__=resource_string(__name__, 'install_prefix.txt').decode('utf-8')
    pass
except IOError: 
    sys.stderr.write("dc_process: error reading install_prefix.txt. Assuming /usr/local.\n")
    __install_prefix__="/usr/local"
    pass



steppath=[".",os.path.join(__install_prefix__,"share","datacollect2","dcp_steps")]

def find_script_in_path(contexthref,scriptname):
    # BUG *** !!!!! We really shouldn't use scriptdir at all,
    # use the scriptpath, but for now we do for backwards compatibility

    if os.path.exists(os.path.join(contexthref.getpath(),scriptname)):
        print("WARNING: direct paths to scripts should be specified with <script xlink:href=\"...\"/>. Use the name=\"...\" attribute only for scripts to be found in the script search path")
        pass
    
    if posixpath.isabs(scriptname):
        return dcv.hrefvalue(quote(scriptname))
    
    if posixpath.pathsep in scriptname:
        return dcv.hrefvalue(quote(scriptname),contexthref=contexthref)

    for trypath in steppath:
        if trypath==".":
            trypath=contexthref.getpath()
            pass
        
        if os.path.exists(os.path.join(trypath,scriptname)):
            return dcv.hrefvalue(quote(scriptname),contexthref=dcv.hrefvalue(pathname2url(trypath)+"/"))
        pass
    
    raise IOError("Could not find script %s in path %s" % (scriptname,unicode(steppath)))

class stepparamvalue(object):
    numvalue=None
    strvalue=None
    hrefvalue=None
    xpath=None
    xpathnsmap=None
    condition=None
    textflag=None
    hrefflag=None  # return a dc_value.hrefvalue object
    hreffullpathflag=None  # return a complete filesystem path,
    numericvalueflag=None  # return a dc_value.numericunitsvalue object
    listflag=None  # return a list of whatever instead of single object

    def __init__(self,**kwargs): # supply name and one of numvalue, strvalue, xpath. Also optionally supply xpathnsmap with xpath, textflag,hrefflag,hreffullpathflag,numericvalueflag,listflag

        for argname in kwargs:
            setattr(self,argname,kwargs[argname])
            pass
        pass

    def test_condition(self,outdoc,element):
        if self.condition is None: 
            return True
        
        result=outdoc.xpathsinglecontext(element,self.condition,variables={"filepath":outdoc.filename,"filename":os.path.split(outdoc.filename)[1]},noprovenance=True)

        # sys.stderr.write("test_condition: condition=%s variables=%s result=%s\n" % (self.condition,str({"filepath":outdoc.filename,"filename":os.path.split(outdoc.filename)[1]}),str(result)))

        if result==True:
            return True
        elif result==False:
            return False
        elif isinstance(result,numbers.Number):
            return result != 0
        else: 
            raise ValueError("test_condition: condition \"%s\" returned invalid result (type %s)" % (self.condition,result.__class__.__name__))
        pass

    def set_condition(self,condition):
        self.condition=condition
        pass

    def evaluatexpathresult(self,outdoc,result):

        if self.textflag:
            result=result.text
            pass
            
        if self.hrefflag:
            #result=outdoc.get_href(contextnode=result)
            result=dcv.hrefvalue.fromxml(outdoc,result)
            pass
        
        if self.hreffullpathflag:
            resulthref=dcv.hrefvalue.fromxml(outdoc,result)
            result=resulthref.getpath()
            pass
            
        if self.numericvalueflag:
            result=dcv.numericunitsvalue.fromxml(outdoc,result)
            pass
        return result

    def evaluate(self,outdoc,element):

        if self.listflag:
            if self.numvalue is not None:
                return [self.numvalue]
            elif self.strvalue is not None:
                return [self.strvalue]
            elif self.hrefvalue is not None:
                return [self.hrefvalue]
            else : 
                assert(self.xpath is not None)
                namespaces=copy.copy(self.xpathnsmap)
                if None in namespaces: 
                    del namespaces[None]
                    pass
                results=[]
                # print "evaluate: xpath=%s" % (self.xpath)
                xpathresults=outdoc.xpathcontext(element,self.xpath,namespaces=namespaces,variables={"filepath":outdoc.get_filehref().getpath(),"filename":outdoc.get_filehref().get_bare_unquoted_filename()})

                for result in xpathresults:
                    results.append(self.evaluatexpathresult(outdoc,result))
                    pass
                return results
            pass
        else: 
            # not listflag
            if self.numvalue is not None:
                return self.numvalue
            elif self.strvalue is not None:
                return self.strvalue
            elif self.hrefvalue is not None:
                return self.hrefvalue
            else : 
                assert(self.xpath is not None)
                namespaces=copy.copy(self.xpathnsmap)
                if None in namespaces: 
                    del namespaces[None]
                    pass
                # print "evaluate: xpath=%s" % (self.xpath)
                xpathresult=outdoc.xpathsinglecontext(element,self.xpath,namespaces=namespaces,default=AttributeError("stepparam.evaluate: XPath \"%s\" not found." % (self.xpath)),variables={"filepath":outdoc.get_filehref().getpath(),"filename":outdoc.get_filehref().get_bare_unquoted_filename()})
                result=self.evaluatexpathresult(outdoc,xpathresult)
                pass
            return result
        pass

    pass


class stepparam(object):
    name=None
    values=None

    def __init__(self,**kwargs): # supply name and value
        self.textflag=False
        self.values=[]

        for argname in kwargs:
            if argname=="value":
                self.values.append(kwargs[argname])
                pass
            else :
                setattr(self,argname,kwargs[argname])
                pass
            pass
        pass

    def addvalue(self,val):
        self.values.append(val)
        pass

    def evaluate(self,outdoc,element):
        for value in self.values:
            if value.test_condition(outdoc,element):
                return value.evaluate(outdoc,element)
            pass
        raise ValueError("No value found for parameter %s for element %s" % (self.name,etxpath2human(outdoc.get_canonical_etxpath(element),outdoc.nsmap)))
        pass
    pass

def findparam(prxnsmap,outdoc,element,argname):
    #     Create a parameter structure for parameter argname from element data
    #  ... xpath nsmap should come from outdoc, but updated by prxdoc

    namespaces={}
    namespaces.update(element.nsmap)
    namespaces.update(prxnsmap)
    if None in namespaces:
        del namespaces[None]
        pass
        
    textflag=False
    hrefflag=False
    hreffullpathflag=False
    numericvalueflag=False
    listflag=False

    if argname.endswith("_list"):
        listflag=True
        argname=argname[:-5]
        pass
    
    if argname.endswith("_text"):
        textflag=True
        useargname=argname[:-5]
        pass
    elif argname.endswith("_href"):
        hrefflag=True
        useargname=argname[:-5]
        pass
    elif argname.endswith("_hreffullpath"):
        hreffullpathflag=True
        useargname=argname[:-13]
        pass
    elif argname.endswith("_numericvalue"):
        numericvalueflag=True
        useargname=argname[:-13]
    else:
        useargname=argname
        pass
    
    if outdoc.child(element,useargname) is not None:
        return stepparam(name=argname,value=stepparamvalue(xpath=useargname,xpathnsmap=namespaces,textflag=textflag,hrefflag=hrefflag,hreffullpathflag=hreffullpathflag,numericvalueflag=numericvalueflag,listflag=listflag))
        
    elif "_" in useargname:

        underscoreoffset=useargname.find("_")
        
        namespaceprefix=useargname[:underscoreoffset]

        tagname=useargname[(underscoreoffset+1):]
        fulltagname=namespaceprefix+":"+tagname
        
        if outdoc.child(element,fulltagname) is not None:
            return stepparam(name=argname,value=stepparamvalue(xpath=fulltagname,xpathnsmap=namespaces,textflag=textflag,hrefflag=hrefflag,hreffullpathflag=hreffullpathflag,numericvalueflag=numericvalueflag,listflag=listflag))
        if outdoc.child(element,useargname) is not None:
            return stepparam(name=argname,value=stepparamvalue(xpath=useargname,xpathnsmap=namespaces,textflag=textflag,hrefflag=hrefflag,hreffullpathflag=hreffullpathflag,numericvalueflag=numericvalueflag,listflag=listflag))
        
        # raise NameError("Tag %s: No %s child element found!" % (outdoc.tostring(element),fulltagname))
        raise NameError("Tag %s: No \"%s\" child element found!" % (etxpath2human(outdoc.get_canonical_etxpath(element),outdoc.nsmap),fulltagname))
        
    else: 
        # raise NameError("Tag %s: No %s child element found!" % (outdoc.tostring(element),argname))
        #import pdb
        #
        #pdb.set_trace()
        
        raise NameError("Tag %s: No \"%s\" child element found!" % (etxpath2human(outdoc.get_canonical_etxpath(element),outdoc.nsmap),argname))
    pass


def procstepmatlab(*args,**kwargs):
    # *** output should be rwlock'd exactly ONCE when this is called
    # *** Output will be rwlock'd exactly ONCE on return
    #     (but may have been unlocked in the interim)
    raise NotImplementedError("procstepmatlab")

def procsteppython_do_run(stepglobals,runfunc,argkw,ipythonmodelist,action,scripthref,pycode_text,pycode_lineno):

    if not ipythonmodelist[0]:
        resultdict=runfunc(**argkw)
        return resultdict
    else:
        # ipython mode
        # in-process kernel, a-la https://raw.githubusercontent.com/ipython/ipython/master/examples/Embedding/inprocess_qtconsole.py

        ## Set PyQt4 API version to 2 and import it -- required for ipython compatibility
        #import sip
        #sip.setapi('QVariant', 2)
        #sip.setapi('QString', 2)
        #sip.setapi('QDateTime', 2)
        #sip.setapi('QDate', 2)
        #sip.setapi('QTextStream', 2)
        #sip.setapi('QTime', 2)
        #sip.setapi('QUrl', 2)
        #from PyQt4 import QtGui   # force IPython to use PyQt4 by importing it first

        # RHEL6 compatibility  -- if running under Python 2.6, just import IPython, get PyQt4
        if sys.version_info < (2,7):
            from IPython.qt.console.rich_ipython_widget import RichIPythonWidget
            from IPython.qt.inprocess import QtInProcessKernelManager
            pass
        else: 

            # Under more recent OS's: Make matplotlib use PySide
            # http://stackoverflow.com/questions/6723527/getting-pyside-to-work-with-matplotlib
            import matplotlib
            matplotlib.use('Qt4Agg')
            matplotlib.rcParams['backend.qt4']='PySide'
            pass

        from IPython.lib import guisupport
        app = guisupport.get_app_qt4() 

        from IPython.qt.inprocess import QtInProcessKernelManager
        kernel_manager = QtInProcessKernelManager()
        kernel_manager.start_kernel()
        kernel = kernel_manager.kernel
        kernel.gui = 'qt4'
        
        # Should we attempt to run the function here?
        
        gui, backend, clobbered = kernel.shell.enable_pylab("qt4",import_all=False) # (args.gui, import_all=import_all)

        kernel.shell.push(stepglobals) # provide globals as variables
        kernel.shell.push(argkw) # provide arguments as variables
        
        kernel.shell.push({"kernel":kernel},interactive=False) # provide kernel for debugging purposes

        kernel_client = kernel_manager.client()
        kernel_client.start_channels()
        abort_requested_list=[False] # encapsulated in a list to make it mutable

        def stop():
            control.hide()
            kernel_client.stop_channels()
            kernel_manager.shutdown_kernel()
            app.exit()
            pass

        def abort():
            # simple exit doesn't work. See http://stackoverflow.com/questions/1527689/exit-from-ipython
            # too bad this doesn't work right now!!!
            class Quitter(object):
                def __repr__(self):
                    sys.exit()
                pass
            kernel.shell.push({"quitter":Quitter()})
            kernel.shell.ex("quitter")

            stop()
            abort_requested_list.pop()
            abort_requested_list.append(True)
            pass
        
        if pycode_text is None:            
            kernel.shell.write("\n\nExecute %s/%s\n" % (scripthref.getpath(),runfunc.__name__))
            pass
        else: 
            kernel.shell.write("\n\nExecute %s/%s/%s\n" % (scripthref.getpath(),action,runfunc.__name__))
            pass

        kernel.shell.write("Assign return value to \"ret\" and press Ctrl-D\n")
        kernel.shell.write("Set cont=True to disable interactive mode\n")
        # kernel.shell.write("call abort() to exit\n")

        from IPython.qt.console.rich_ipython_widget import RichIPythonWidget
        control = RichIPythonWidget()
        control.kernel_manager = kernel_manager
        control.kernel_client = kernel_client
        control.exit_requested.connect(stop)
        control.show()


        #sys.stderr.write("lines=%s\n" % (str(lines)))
        #sys.stderr.write("lines[0]=%s\n" % (str(lines[0])))
        try:
            if pycode_text is None:
                (lines,startinglineno)=inspect.getsourcelines(runfunc)
                
                assert(lines[0].startswith("def")) # first line of function is the defining line
                del lines[0] # remove def line
                lines.insert(0,"if 1:\n") # allow function to be indented
                runfunc_syntaxtree=ast.parse("".join(lines), filename=scripthref.getpath(), mode='exec') # BUG: Should set dont_inherit parameter and properly determine which __future__ import flags should be passed

                # fixup line numbers
                for syntreenode in ast.walk(runfunc_syntaxtree):
                    if hasattr(syntreenode,"lineno"):
                        syntreenode.lineno+=startinglineno-1
                        pass
                    pass

                # runfunc_syntaxtree should consist of the if statement we just added
                # use _fields attribute to look up fields of an AST element
                # (e.g. test, body, orelse for IF)
                # then those fields can be accessed directly
                assert(len(runfunc_syntaxtree.body)==1)
                code_container=runfunc_syntaxtree.body[0]
                assert(isinstance(code_container,ast.If)) # code_container is the if statement we just wrote
                
                kernel.shell.push({"runfunc_syntaxtree": runfunc_syntaxtree},interactive=False) # provide processed syntax tree for debugging purposes

                pass
            else : 
                fullsyntaxtree=ast.parse(pycode_text) # BUG: Should set dont_inherit parameter and properly determine which __future__ import flags should be passed
                # fixup line numbers
                for syntreenode in ast.walk(fullsyntaxtree):
                    if hasattr(syntreenode,"lineno"):
                        syntreenode.lineno+=pycode_lineno-1
                        pass
                    pass
                code_container=None
                for codeelement in fullsyntaxtree.body:
                    if isinstance(codeelement,ast.FunctionDef):
                        if codeelement.name==runfunc.__name__:
                            code_container=codeelement
                            pass
                        pass
                    
                    pass
                if code_container is None: 
                    raise ValueError("Couldn't find code for %s for ipython execution" % (runfunc.__name__)) 

                kernel.shell.push({"fullsyntaxtree": fullsyntaxtree},interactive=False) # provide full syntax tree for debugging purposes
                
                pass
            
            
            kernel.shell.push({"abort": abort}) # provide abort function
            kernel.shell.push({"cont": False}) # continue defaults to False



            
            returnstatement=code_container.body[-1]
            if isinstance(returnstatement,ast.Return):
                # last statement is a return statement!
                # Create assign statement that assigns 
                # the result to ret
                retassign=ast.Assign(targets=[ast.Name(id="ret",ctx=ast.Store(),lineno=returnstatement.lineno,col_offset=returnstatement.col_offset)],value=returnstatement.value,lineno=returnstatement.lineno,col_offset=returnstatement.col_offset)
                del code_container.body[-1] # remove returnstatement
                code_container.body.append(retassign) # add assignment
                pass
            

            runfunc_lines=code_container.body

            kernel.shell.push({"runfunc_lines": runfunc_lines,"scripthref": scripthref},interactive=False) # provide processed syntax tree for debugging purposes
            
            # kernel.shell.run_code(compile("kernel.shell.run_ast_nodes(runfunc_lines,scriptpath,interactivity='all')","None","exec"))
            from IPython.external.qt import QtCore
            QTimer=QtCore.QTimer

            def showret():
                control.execute("ret")
                pass
                
            
            def runcode():
                control.execute("kernel.shell.run_ast_nodes(runfunc_lines,scripthref.getpath(),interactivity='none')")
                # QTimer.singleShot(25,showret) # get callback 25ms into main loop
                # showret disabled because it prevents you from running the 
                # debugger in post-mortem mode to troubleshoot an exception:
                # import pdb; pdb.pm() 
                pass
            
            QTimer.singleShot(25,runcode) # get callback 25ms into main loop
            # control.execute("kernel.shell.run_ast_nodes(runfunc_lines,scripthref.getpath(),interactivity='none')")

            pass
        except:
            (exctype, excvalue) = sys.exc_info()[:2] 
            sys.stderr.write("%s while attempting to prepare URL %s code for interactive execution: %s\n" % (exctype.__name__,scripthref.absurl(),str(excvalue)))
            traceback.print_exc()
            raise




        guisupport.start_event_loop_qt4(app) 
        if abort_requested_list[0]:
            pass
        
        if kernel.shell.ev("cont"):
            # cont==True -> disable interactive mode
            ipythonmodelist.pop()
            ipythonmodelist.append(False)
            pass
        

        try : 
            return kernel.shell.ev("ret") # Assign result dictionary to "ret" variablex
        except NameError: # if ret not assigned, return {}
            return {}
        pass
    pass


def applyresultdict(output,prxdoc,steptag,element,resultdict):
    # resultdict can either be a dict
    # or a list/tuple of (key,element) pairs. 
    # tuple use case is so that what would otherwise be a key
    # can itself contain a dictionary of attributes

    if isinstance(resultdict,collections.Mapping):
        # dictionary or dictionary-like: 
        # Convert to list of (key,element) pairs
        resultlist=[ (key,resultdict[key]) for key in resultdict.keys() ]
        pass
    else:
        # list or tuple
        resultlist=resultdict
        pass

    # Go through results...
    for (resultname,resultitem) in resultlist: 


        #  resultitem=resultdict[resultname]
        attrdict={}
        if isinstance(resultname,tuple):
            # if result is a tuple, then treat first element 
            # of tuple as actual name, second element as attribute dictionary, 
            assert(len(resultname)==2)
            attrdict.update(resultname[1])
            name=resultname[0]
            pass
        else: 
            name=resultname
            pass

        if not ":" in name:
            sys.stderr.write("dc_process.applyresultdict() WARNING: Results from dc_process\nsteps should always specify the XML namespace of result tags\nOtherwise they get placed in the default namespace, but not replaced on the next run.\n")
            pass


        if isinstance(resultitem,tuple):
            # if result is a tuple, then treat first element 
            # of tuple as an attribute dictionary, second
            # element as value object
            assert(len(resultitem)==2)
            attrdict.update(resultitem[0])
            resultvalue=resultitem[1]
            pass
        else: 
            resultvalue=resultitem
            pass
        
        # Remove preexisting elements if present
        oldelements=output.children(element,name,noprovenanceupdate=True)
        for oldelement in oldelements:
            # do the requested attributes match?
            attrmatch=True

            for attrname in attrdict:
                if not(output.hasattr(oldelement,attrname)) or output.getattr(oldelement,attrname)!=attrdict[attrname]:
                    attrmatch=False
                    break
                pass
            
            if attrmatch: 
                # no attribute mismatch... remove element
                output.removeelement(oldelement)
                pass
            pass
        
        # Create new element according to type
        # sys.stderr.write("resultdict=%s\n" % (str(resultdict))) 
        if isinstance(resultvalue,numbers.Number):
            newel=output.addsimpleelement(element,name,(resultvalue,))
            pass
        elif isinstance(resultvalue,dcv.value):
            newel=output.addelement(element,name)
            resultvalue.xmlrepr(output,newel)
            pass
        elif isinstance(resultvalue,basestring):
            newel=output.addelement(element,name)
            output.settext(newel,resultvalue)
            pass

        else :
            raise ValueError("step %s gave unknown result type %s for %s" % (prxdoc.tostring(steptag),unicode(resultvalue.__class__),name))
        
        # add attributes to newel
        for attrname in attrdict:
            output.setattr(newel,attrname,attrdict[attrname])
            pass

        pass
    pass

def procsteppython_runelement(output,prxdoc,prxnsmap,steptag,rootprocesspath,stepprocesspath,elementpath,stepglobals,argnames,argsdefaults,params,cwd_fd,inputfilehref,ipythonmodelist,execfunc,action,scripthref,pycode_text,pycode_lineno):
    # *** output should be rwlock'd exactly ONCE when this is called
    # *** Output will be rwlock'd exactly ONCE on return
    #     (but may have been unlocked in the interim)



    element=output.restorepath(elementpath)

    print("Element %s\r" % (canonicalize_path.getelementhumanxpath(output,element,nsmap=prxnsmap)),end="\r")
    sys.stdout.flush()

    rootprocess_el=output.restorepath(rootprocesspath)
    
    provenance.starttrackprovenance()
    try : # try-catch-finally block for starttrackprovenance()
        
        argkw={}
        
        #sys.stderr.write("argnames=%s\n" % (str(argnames)))
        #sys.stderr.write("params.keys()=%s\n" % (str(params.keys())))
        
        for argname in argnames:
            if argname in params:
                # calling evaluate tracks provenance!
                # returns XML element for auto-params or xpaths
                # returns dc_value for fixed numeric params
                # returns string for fixed string params
                argkw[argname]=params[argname].evaluate(output,element)
                pass
            elif argname=="_xmldoc":  # _xmldoc parameter gets output XML document
                argkw[argname]=output         # supply output XML document
                pass
            elif argname=="_inputfilename":  # _inputfilename parameter gets unquoted name (but not path) of input file
                argkw[argname]=inputfilehref.get_bare_unquoted_filename()
                pass
            elif argname=="_element" or argname=="_tag": # _element (formerly _tag) parameter gets current tag we are operating on
                argkw[argname]=element
                pass
            # ** TODO ***!!!  add _dest_href support!
            elif argname=="_dest_href":
                # Get hrefvalue pointing at destination directory, where
                # files should be written
                destlist=output.xpath("dc:summary/dc:dest")
                argkw[argname]=None
                if len(destlist)==1:
                    argkw[argname]=dcv.hrefvalue.fromxml(output,destlist[0])
                    pass
                pass
            else : 
                try : 
                    argkw[argname]=findparam(prxnsmap,output,element,argname).evaluate(output,element)
                    pass
                except (NameError,KeyError):
                    # if there is a default, use that
                    if argname in argsdefaults:
                        argkw[argname]=argsdefaults[argname]
                        pass
                    else:
                        raise  # Let user know we can't find this!
                    pass
                pass
            pass
        
        # unlock XML file if "rununlocked" so parallel processes can mess with it

        #os.chdir(destdir) # CD into destination directory
        try :  # try... catch.. finally.. block for changed directory
            if execfunc.__name__.endswith("unlocked"): 
                assert(not "_tag" in argnames) # can't supply tag if lock is released
                output.unlock_rw() # release output lock 
                try: 
                    resultdict=procsteppython_do_run(stepglobals,execfunc,argkw,ipythonmodelist,action,scripthref,pycode_text,pycode_lineno)
                    pass
                finally: 
                    output.lock_rw() # secure output lock ... otherwise
                    # an exception would be handled several levels above
                    # which assumes we are locked. 
                    pass

                del rootprocess_el
                element=output.restorepath(elementpath)
                
                pass
            else: 
                resultdict=procsteppython_do_run(stepglobals,execfunc,argkw,ipythonmodelist,action,scripthref,pycode_text,pycode_lineno)
                
            
                output.should_be_rwlocked_once() # Verify that after running, the output is still locked exactly once
                element=output.restorepath(elementpath) # run function may have unlocked output temporarily so we need to restore the element from its path
                pass
            pass
        except: 
            raise
        finally: 
            #os.fchdir(cwd_fd) # CD back to regular directory
            pass
        
        if resultdict is None: 
            resultdict={}  # no results provided
            pass
        

        applyresultdict(output,prxdoc,steptag,element,resultdict)
    
        pass
    except:
        raise
    finally:
        (modified_elements,referenced_elements)=provenance.finishtrackprovenance()
        pass

    # exit with output still in locked state. 
    return (modified_elements,referenced_elements)
    


def procsteppython_execfunc(scripthref,pycode_text,pycode_lineno,prxdoc,prxnsmap,output,steptag,scripttag,rootprocesspath,stepprocesspath,stepglobals,elementmatch,elementmatch_nsmap,params,filters,cwd_fd,inputfilehref,debugmode,ipythonmodelist,execfunc,action):
    
    
    (argnames, varargs, keywords, defaults)=inspect.getargspec(execfunc)        
    
    argsdefaults={}
    if defaults is not None:
        numdefaults=len(defaults)
        argsdefaults=dict(zip(argnames[-numdefaults:],defaults))
        # argsdefaults is a dictionary by argname of default values.
        pass
    if None in elementmatch_nsmap:
        del elementmatch_nsmap[None]  # Can not pass None entry
        pass
    # Add filters to elementmatch
    
    for elementfilter in filters:
        elementmatch+="[%s]" % (elementfilter)
        pass

    # Search for matching elements

    # sys.stderr.write("elementmatch=%s\n" % (elementmatch))
    elements=output.xpath(elementmatch,namespaces=elementmatch_nsmap,variables={"filepath":output.filehref.getpath(),"filename":os.path.split(output.filehref.getpath())[1]})


    if len(elements)==0:
        sys.stderr.write("Warning: step %s: no matching elements for output href%s\n" % (dc_process_common.getstepname(prxdoc,steptag),output.get_filehref().absurl()))
        pass
    

    elementpaths=[ output.savepath(element) for element in elements]

    # output.unlock_rw() # release output lock

    

    # Loop over each matching element
    for elementpath in elementpaths:

        modified_elements=set([])
        referenced_elements=set([])

        el_starttime=dg_timestamp.now().isoformat()
        
        # Capture python stdio/stderr 
        errcapt=StringIO()
        stdouthandler.set_dest(errcapt)
        stderrhandler.set_dest(errcapt)

        status="success"

        output.should_be_rwlocked_once()

        try : 
            (modified_elements,referenced_elements)=procsteppython_runelement(output,prxdoc,prxnsmap,steptag,rootprocesspath,stepprocesspath,elementpath,stepglobals,argnames,argsdefaults,params,cwd_fd,inputfilehref,ipythonmodelist,execfunc,action,scripthref,pycode_text,pycode_lineno)
            pass
        except KeyboardInterrupt: 
            # Don't want to hold off keyboard interrupts!
            raise
        except: 
            (exctype, excvalue) = sys.exc_info()[:2] 
            
            
            sys.stderr.write("%s while processing step %s element on element %s in file %s: %s\n" % (exctype.__name__,action,etxpath2human(elementpath,output.nsmap),output.filehref.getpath(),unicode(excvalue)))
            traceback.print_exc()
            
            status="exception"
            
            if debugmode and sys.stdin.isatty() and sys.stderr.isatty():
                # automatically start the debugger from an exception in debug mode (if stdin and stderr are ttys) 
                import pdb # Note: Should we consider downloading/installing ipdb (ipython support for pdb)???
                # run debugger in post-mortem mode. 
                pdb.post_mortem()
                pass


            pass

        stdouthandler.set_dest(None)
        stderrhandler.set_dest(None)

        output.should_be_rwlocked_once()

        rootprocess_el=output.restorepath(rootprocesspath)
        # Create dcp:process element that contains dcp:used tags listing all referenced elements
        element=output.restorepath(elementpath)
        # print "Reference location=%s" % (canonicalize_path.create_canonical_etxpath(output.filename,output.doc,rootprocess_el.getparent()))
        # print "Target location=%s" % (canonicalize_path.create_canonical_etxpath(output.filename,output.doc,element))
        # print "Relative location=%s" % (canonicalize_path.relative_etxpath_to(canonicalize_path.create_canonical_etxpath(output.filename,output.doc,rootprocess_el.getparent()),canonicalize_path.create_canonical_etxpath(output.filename,output.doc,element)))

        targetpath=canonicalize_path.relative_etxpath_to(canonicalize_path.create_canonical_etxpath(output.filehref.getpath(),output.doc,rootprocess_el.getparent()),canonicalize_path.create_canonical_etxpath(output.filehref.getpath(),output.doc,element))
    # targetpath=output.savepath(element)

        process_el=provenance.writeprocessprovenance(output,rootprocesspath,stepprocesspath,referenced_elements)
        
        # write timestamps
        provenance.write_timestamp(output,process_el,"dcp:starttimestamp",el_starttime)
        provenance.write_timestamp(output,process_el,"dcp:finishtimestamp")
        provenance.write_process_info(output,process_el)  # We always write process info to ensure uniqueness of our UUID. It would be better to merge with parent elements before calculating UUID.
        provenance.write_process_log(output,process_el,status,errcapt.getvalue())

        provenance.write_target(output,process_el,targetpath)  # dcp:target -- target of this particular iteration (ETXPath)
    
        # Generate uuid
        process_uuid=provenance.set_hash(output,rootprocess_el,process_el)
    
        # Mark all modified elements with our uuid
        provenance.mark_modified_elements(output,modified_elements,process_uuid)

        errcapt.close()
        del errcapt

        output.should_be_rwlocked_once() 

        pass

    pass

def procsteppython(scripthref,pycode_el,prxdoc,output,steptag,scripttag,rootprocesspath,initelementmatch,initelementmatch_nsmap,elementmatch,elementmatch_nsmap,params,filters,cwd_fd,inputfilehref,debugmode,ipythonmodelist):
    # *** output should be rwlock'd exactly ONCE when this is called
    # *** Output will be rwlock'd exactly ONCE on return
    #     (but may have been unlocked in the interim)

    prxnsmap=dict(prxdoc.getroot().nsmap)

    stepglobals={}

    # !!!*** NON-REENTRANT
    # Temporarily adjust sys.path so as to add script's directory 
    
    syspath_save=sys.path
    syspath_new=copy.deepcopy(syspath_save)
    syspath_new.insert(0,os.path.split(scripthref.getpath())[0])
    sys.path=syspath_new

    if pycode_el is None: 
        #execfile(scripthref.getpath(),stepglobals)  # load in step
        
        with open(scripthref.getpath()) as f:
            code = compile(f.read(), scripthref.getpath(), 'exec')
            exec(code, stepglobals)
            pass
        
        pycode_text=None
        pycode_lineno=None
        pass
    else: 
        pycode_text=pycode_el.text
        pycode_lineno=pycode_el.sourceline
        # precede code with pycode_lineno blank lines so that parse errors, etc. get the right line number
        #pycode_parsed=ast.parse(("\n"*(pycode_lineno-1))+pycode_text,scriptpath)
        pycode_compiled=compile(("\n"*(pycode_lineno-1))+pycode_text,scripthref.getpath(),"exec")
        exec(pycode_compiled,stepglobals)
        pass
    sys.path=syspath_save
    
    # Find modules imported or referenced
    modules=set()
    for variable in stepglobals:
        if hasattr(variable,"__module__"):
            modulename=variable.__module__
            pass
        elif hasattr(variable,"__package__"):
            modulename=variable.__package__
            pass
        else: 
            continue
        modulenamesplit=modulename.split(".")
        for modulenamecomponentcnt in range(1,len(modulenamesplit)):
            trymodulename=".".join(modulenamesplit[:modulenamecomponentcnt])
            modules.add(trymodulename)
            pass
        pass
    # *** should Save module.__version__ and other version parameters with provenance!!!

    # create <dcp:process> tag for this step 
    
    # output lock should be locked exactly once by caller
    output.should_be_rwlocked_once()
    #output.lock_rw()  # secure output lock

    rootprocess_el=output.restorepath(rootprocesspath)



    stepprocess_el=output.addelement(rootprocess_el,"dcp:process")
    provenance.write_timestamp(output,stepprocess_el,"dcp:starttimestamp")
    
    action=dc_process_common.getstepname(prxdoc,steptag)
    provenance.write_action(output,stepprocess_el,action)
    for module in (set(sys.modules.keys()) & modules):  # go through modules
        provenance.reference_pymodule(output,stepprocess_el,"dcp:used",rootprocess_el.getparent(),module,warnlevel="none")
        pass

    provenance.write_process_info(output,stepprocess_el) # ensure uniqueness prior to uuid generation

    # Generate uuid
    stepprocess_uuid=provenance.set_hash(output,rootprocess_el,stepprocess_el)
    stepprocesspath=output.savepath(stepprocess_el)


    argkw={}

    initfunc=None
    
    # find "init" function or method
    if prxdoc.hasattr(steptag,"initfunction"):
        initfunc=stepglobals[prxdoc.getattr(steptag,"initfunction")]
        pass
    elif "initunlocked" in stepglobals:
        initfunc=stepglobals["initunlocked"]
        pass
    elif "init" in stepglobals : 
        initfunc=stepglobals["init"]
        pass

    if initfunc is not None:
        procsteppython_execfunc(scripthref,pycode_text,pycode_lineno,prxdoc,prxnsmap,output,steptag,scripttag,rootprocesspath,stepprocesspath,stepglobals,initelementmatch,initelementmatch_nsmap,params,[],cwd_fd,inputfilehref,debugmode,ipythonmodelist,initfunc,action)
        pass
    
    
    # find "run" function or method
    if prxdoc.hasattr(steptag,"function"):
        runfunc=stepglobals[prxdoc.getattr(steptag,"function")]
        pass
    elif "rununlocked" in stepglobals:
        runfunc=stepglobals["rununlocked"]
        pass
    else : 
        runfunc=stepglobals["run"]
        pass


    procsteppython_execfunc(scripthref,pycode_text,pycode_lineno,prxdoc,prxnsmap,output,steptag,scripttag,rootprocesspath,stepprocesspath,stepglobals,elementmatch,elementmatch_nsmap,params,filters,cwd_fd,inputfilehref,debugmode,ipythonmodelist,runfunc,action)

    print("") # add newline

    # output.lock_rw()
    stepprocess_el=output.restorepath(stepprocesspath)
    provenance.write_timestamp(output,stepprocess_el,"dcp:finishtimestamp")
    # output.unlock_rw()
    

    pass


def procstep(scriptdirhref,prxdoc,output,steptag,processpath,defaultelementmatch,defaultelementmatch_nsmap,filters,cwd_fd,inputfilehref,debugmode,ipythonmodelist):
    # *** output should be unlocked when this is called


    scripttag=prxdoc.xpathsinglecontext(steptag,"prx:script")
    
    elementmatch=defaultelementmatch
    elementmatch_nsmap=defaultelementmatch_nsmap
    # sys.stderr.write("defaultelementmatch=%s\n" % (elementmatch))

    # try for <prx:elementmatch> in <step> 
    try: 
        elementmatchel=prxdoc.xpathsinglecontext(steptag,"prx:elementmatch")
        elementmatch=elementmatchel.text
        # sys.stderr.write("overrideelementmatch=%s\n" % (elementmatch))
        elementmatch_nsmap=elementmatchel.nsmap
        pass
    except NameError:
        pass

    # try for <prx:elementmatch> in <script> 
    try: 
        elementmatchel=prxdoc.xpathsinglecontext(scripttag,"prx:elementmatch")
        elementmatch=elementmatchel.text
        # sys.stderr.write("overrideelementmatch=%s\n" % (elementmatch))
        elementmatch_nsmap=elementmatchel.nsmap
        pass
    except NameError:
        pass

    initelementmatch="/*" # select root element
    initelementmatch_nsmap={}

    try: 
        initelementmatchel=prxdoc.xpathsinglecontext(scripttag,"prx:initelementmatch")
        initelementmatch=initelementmatchel.text
        initelementmatch_nsmap=initelementmatchel.nsmap
        pass
    except NameError:
        pass

                         
    pycode_el=None
    if prxdoc.hasattr(scripttag,"xlink:href"): 
        #scriptpath=prxdoc.get_href_fullpath(contextnode=scripttag)
        scripthref=dcv.hrefvalue.fromxml(prxdoc,scripttag)
        #scriptpath=scripthref.getpath()
        pass
    elif prxdoc.hasattr(scripttag,"name"): 
        scripthref=find_script_in_path(prxdoc.filehref,prxdoc.getattr(scripttag,"name"))
        pass
    else: 
        pycode_el=prxdoc.child(scripttag,"prx:pycode") # set to pycode tag or None
        scripthref=prxdoc.filehref
        if pycode_el is None: 
            raise ValueError("script %s does not specify file or python code" % (prxdoc.tostring(scripttag)))
        pass

    # Build parameter list
    params={}
    
    # ***!!! Note: Should there be a separate class of parameters for xlink:href? 

    for paramel in prxdoc.xpathcontext(steptag,"prx:parameter|prx:script/prx:parameter"):
        paramname=prxdoc.getattr(paramel,"name")
        param=stepparam(name=paramname)
        for child in prxdoc.xpathcontext(paramel,"*"):
            if prxdoc.tag_is(child,"prx:numvalue"):
                value=stepparamvalue(numvalue=dcv.numericunitsvalue.fromxml(prxdoc,child))
                pass
            elif prxdoc.tag_is(child,"prx:strvalue"):
                value=stepparamvalue(strvalue=prxdoc.gettext(child))
                pass
            elif prxdoc.tag_is(child,"prx:hrefvalue"):
                value=stepparamvalue(hrefvalue=prxdoc.get_href(child),xpathnsmap=child.nsmap)
                pass
            elif prxdoc.tag_is(child,"prx:xpath"):
                value=stepparamvalue(xpath=child.text,xpathnsmap=child.nsmap)
                pass
            else :
                raise ValueError("Parameter element %s contains unknown value tag %s" % (prxdoc.tostring(paramel),child.tag))
            
                #raise NameError("Parameter element %s missing value tag" % (prxdoc.tostring(paramel)))
            if prxdoc.hasattr(child,"condition"):
                value.set_condition(prxdoc.getattr(child,"condition"))
                pass
            param.addvalue(value)
            pass
        params[param.name]=param
        
        pass

    output.lock_rw() # procsteppython/procstepmatlab are called with output locked exactly once
    try : 
        if pycode_el is not None or scripthref.get_bare_unquoted_filename().endswith(".py"):
            procsteppython(scripthref,pycode_el,prxdoc,output,steptag,scripttag,processpath,initelementmatch,initelementmatch_nsmap,elementmatch,elementmatch_nsmap,params,filters,cwd_fd,inputfilehref,debugmode,ipythonmodelist)
            pass
        elif scriptpath.endsith(".m"):
            procstepmatlab(scriptdirhref,scriptpath,prxdoc,output,steptag,scripttag,processpath,elementmatch,elementmatch_nsmap,params,filters,cwd_fd,inputfilehref,debugmode,ipythonmodelist)
            pass
        pass
    except: 
        raise
    finally: 
        output.unlock_rw() # procsteppython/procstepmatlab are called with output locked exactly once
        pass

    pass



def usage():
    print ("""Usage: %s [-s step1name] [-s step2name]  [-a] [-d] [-p dir] [-l xpathconstraint1] [-l xpathconstraint2] [-f inputfile] ... process.prx
process.prx specifies processing steps.
      
Flags:
  -s                  Run only listed steps (multiple OK)
  -a                  Run all steps
  -d                  Drop into debugger in case of exception executing step
  -f                  Operate only on the specified input files (multiple OK)
  -l                  Apply additional xpath filters (multiple OK)
  -p                  Additional search path entry for finding scripts
                      (inserted between current directory and %s) (multiple OK)
  -i                  Use ipython interactive mode to execute script
  --gtk3              Use GTK3 if gui elements required
  --steps             Don't do anything; just list available steps
  --files             Don't do anything; just list available files 
    """ % (sys.argv[0],steppath[1]))
    pass

if __name__=="__main__":

    argv_inputfiles=set([])

    overall_starttime=dg_timestamp.now().isoformat()

    cwd_fd=os.open(".",os.O_RDONLY) # file descriptor for current working directory. Can pass to os.fchdir()

    argc=1
    positionals=[]
    stepnames=[]
    filters=[]
    allsteps=False
    liststeps=False
    listfiles=False
    debugmode=False
    ipythonmodelist=[False] # ipythonmode is contained within a list so it is mutable by functions and these changes will be persistent
    
    while argc < len(sys.argv):
        arg=sys.argv[argc]
        
        if arg=="-s":  # -s <step>: Only run this (or these) steps
            stepnames.append(sys.argv[argc+1])
            argc+=1
            pass
        elif arg=="--steps": # just list steps
            liststeps=True
            pass
        elif arg=="-l": # -l <filter>: Apply additional filtering constraint 
                        # to elements operated on 
            filters.append(sys.argv[argc+1])
            argc+=1
            pass
        elif arg=="-f": # -f <inputfile>: Operate only on the specified file
            argv_inputfiles.add(sys.argv[argc+1])
            argc+=1
            pass
        elif arg=="--files": # just list files
            listfiles=True
            pass
        elif arg=="-a": # run all steps
            allsteps=True
            pass
        elif arg=="-i": # enable ipython qtconsole mode
            ipythonmodelist.pop()
            ipythonmodelist.append(True)
            pass
        elif arg=="-d": # enable debugging mode
            debugmode=True
            pass
        elif arg=='--gtk3':
            # handled at imports, above
            pass
        elif arg=="-p":  # insert path into search path for steps
            steppath.insert(1,sys.argv[argc+1])
            argc+=1
            pass
        elif arg=='-h' or arg=="--help":
            usage()
            sys.exit(0)
            pass
        elif arg[0]=='-':
            raise ValueError("Unknown command line switch %s" % (arg))
        else :
            positionals.append(arg)
            pass
        argc+=1
        pass
        
    if len(positionals) > 1:
        raise ValueError("Too many positional parameters (see -h for command line help")

    if len(positionals) < 1: 
        usage()
        sys.exit(0)
        pass
        
        
    prxfile=positionals[0]
    prxfilehref=dcv.hrefvalue(prxfile,contexthref=None)
    scriptdirhref=prxfilehref.leafless()

    prx_nsmap={
        "prx": "http://thermal.cnde.iastate.edu/datacollect/processinginstructions",
        "dcv": "http://thermal.cnde.iastate.edu/dcvalue",
        "xlink": "http://www.w3.org/1999/xlink",
        };
    
    # prxdoc is loaded into memory once, so we don't use locking on it. 
    prxdoc=xmldoc.xmldoc.loadhref(prxfilehref,nsmap=prx_nsmap,readonly=True,use_locking=False,debug=True)  #!!!*** Should turn debug mode off eventually... it will speed things up
    # prxdoc.merge_namespace("prx",)
    assert(prxdoc.gettag(prxdoc.getroot())=="prx:processinginstructions")

    elementmatch="*" # defaults to all child elements of main tag
    elementmatch_nsmap=None
    try: 
        elementmatchel=prxdoc.xpathsingle("prx:elementmatch")
        elementmatch=elementmatchel.text
        elementmatch_nsmap=elementmatchel.nsmap
        pass
    except NameError:
        pass


    # See if a specific hostname was specified
    hostname=prxdoc.xpathsinglestr("prx:hostname",default=None)

    if hostname is not None and hostname.split(".")[0] != provenance.determinehostname().split(".")[0]:
        sys.stderr.write("Hostname mismatch: %s in <prx:hostname> tag vs. this computer is %s.\nPlease adjust <prx:hostname> tag to match if you really want to run on this computer.\nRemove <prx:hostname> completely if this should be allowed to run on any computer.\n" % (hostname.split(".")[0],provenance.determinehostname().split(".")[0]))
        sys.exit(1)
        pass

        
    if allsteps or liststeps:
        steps=prxdoc.xpath("prx:step")
        pass
    else: # Convert list of step names into list of step elements
        steps=[ dc_process_common.findstep(prxdoc,stepname) for stepname in stepnames ]
        pass

    if liststeps: 
        print("")
        print("List of steps for -s option")
        print("---------------------------")
        for step_el in steps:
            print(dc_process_common.getstepname(prxdoc,step_el))
            pass

        sys.exit(0)
        pass  



    inputfiles=prxdoc.xpath("prx:inputfile")
    outputfiles=prxdoc.xpath("prx:outputfile")
    if len(outputfiles) > 0 and len(outputfiles) != len(inputfiles):
        raise ValueError(".prx URL %s specifies %d input files but %d output files.\nMust either specify ALL output files or NO output files\n" % (prxfilehref.absurl(),len(inputfiles),len(outputfiles)))
    

    if listfiles:
        print("")
        print("List of files for -f option")
        print("---------------------------")
        for inputfile_el in inputfiles:
            if prxdoc.hasattr(inputfile_el,"xlink:href"):
                print(prxdoc.getattr(inputfile_el,"xlink:href"))
                pass
            else:
                sys.stderr.write("WARNING: input file should be specified in xlink:href attribute!")
                print(prxdoc.gettext(inputfile_el))
                pass
            pass

        sys.exit(0)
        pass

    if len(steps)==0:
        print("Nothing to do! (try specifying a step with -s <step> or all steps with -a);\nlist steps with --steps\n")
        sys.exit(0)
        pass

    #print("steps=%s" % str(steps))

    for argv_inputfile in argv_inputfiles:
        if argv_inputfile not in [ prxdoc.gettext(inputfile_el) for inputfile_el in inputfiles ] and argv_inputfile not in [ prxdoc.getattr(inputfile_el,"xlink:href") for inputfile_el in inputfiles ]:
            sys.stderr.write("Specified input URL %s is not listed in %s\nTry listing available files with --files.\n" % (argv_inputfile,prxfilehref.absurl()))
            sys.exit(1)
            pass
        pass
    # inputfile = prxdoc.xpathsinglestr("prx:inputfile")
    for inputfile_cnt in range(len(inputfiles)): 
        inputfile_el=inputfiles[inputfile_cnt]

        if prxdoc.hasattr(inputfile_el,"xlink:href"):
            #inputfileraw=prxdoc.getattr(inputfile_el,"xlink:href")
            #inputfile=prxdoc.get_href_fullpath(inputfile_el)
            inputfilehref=dcv.hrefvalue.fromxml(prxdoc,inputfile_el)
            #inputfile=inputfilehref.getpath()
            pass
        else:
            print("WARNING: input file should be specified in xlink:href attribute!")
            inputfileraw=prxdoc.gettext(inputfile_el)
            inputfilehref=dcv.hrefvalue(inputfileraw,scriptdirhref)
            #inputfile=inputfileraw
            #if not(os.path.isabs(inputfile)):
            #    inputfile=hrefvalue(os.path.join(scriptdir,inputfile)
            #    pass
            #
            pass
        
        if len(argv_inputfiles) > 0: # input files specified on command line
            if inputfileraw not in argv_inputfiles:
                continue # skip over input files we are supposed to ignore
            pass

        #(inputdir,inputfilename)=os.path.split(inputfile)


        
        outputfilehref=None

        try:
            outputfiletag=prxdoc.xpathsingle("prx:outputfile[%d]" % (inputfile_cnt+1))
            if prxdoc.hasattr(outputfiletag,"xlink:href"):
                #outputfile=prxdoc.get_href_fullpath(outputfiletag)
                outputfilehref=dcv.hrefvalue.fromxml(prxdoc,outputfiletag)
                #outputfile=outputfilehref.getpath()
            else:
                outputfileraw=prxdoc.gettext(outputfiletag)
                outputfilehref=dcv.hrefvalue(outputfile,scriptdirhref)
                #if not os.path.isabs(outputfile):
                #    outputfile=os.path.join(scriptdir,outputfile)
                #    pass
                pass
            
            pass
        except NameError:
            pass

        if outputfilehref is None:

            if posixpath.splitext(inputfilehref.get_bare_unquoted_filename())[1]==".xlg":
                outputfilehref=dcv.hrefvalue(quote(posixpath.splitext(inputfilehref.get_bare_unquoted_filename())[0]+".xlp"),inputfilehref.leafless())
                pass

            # if not(os.path.isabs(outputfile)):
            #    outputfile=os.path.join(scriptdir,outputfile)
            #    pass
        
        
        
        print("\n\nProcessing input URL %s to output URL %s." % (inputfilehref.absurl(),outputfilehref.absurl())) 

        copiedfile=False
        inputfilter=None
        if not os.path.exists(outputfilehref.getpath()):
            # Need to create outputfile by copying or running inputfilter
            cf_starttime=dg_timestamp.now().isoformat()

            # Do we have an input filter? ... stored as xlink:href in <inputfilter> tag
            inputfilters=prxdoc.xpath("inputfilter")
            if len(inputfilters) > 1:
                raise ValueError("Maximum of one <inputfilter> element permitted in .prx file")
            if len(inputfilters) > 0:
                # have an input filter
                inputfilter=inputfilters[0]

                # run input filter
                # Get path from xlink:href
                #inputfilterpath=prxdoc.get_href_fullpath(inputfilter)
                inputfilterhref=dcv.hrefvalue.fromxml(prxdoc,inputfilter)
                inputfilterpath=inputfilterhref.getpath()
                # build arguments
                inputfilterargs=[inputfilterpath]

                # pull attributes named param1, param2, etc. from inputfilter tag
                cnt=1
                while "param"+cnt in inputfilter.attrib:
                    inputfilterargs.append(inputfilter.attrib["param"+cnt])
                    cnt+=1
                    pass

                # add input and output filenames as params to filter
                inputfilterargs.append(inputfilehref.getpath())
                inputfilterargs.append(outputfilehref.getpath())

                # Call input filter... will raise
                # exception if input filter fails. 
                subprocess.check_call(*inputfilterargs)
                
                pass
            else:
                # use shutil to copy input to output
                shutil.copyfile(inputfilehref.getpath(),outputfilehref.getpath())
                pass
            
            # Will mark provenance of each element of output file
            copiedfile=True
            
            pass

    
        output=xmldoc.xmldoc.loadhref(outputfilehref,readonly=False,num_backups=50,use_locking=True,nsmap=outputnsmap,debug=True) # !!!*** Remove debug mode eventually for performance reasons
        if copiedfile:
            sys.stderr.write("Merging dcp namespace!\n")
            output.lock_rw()
            try: 
                output.merge_namespace("dcp","http://thermal.cnde.iastate.edu/datacollect/provenance")
                output.suggest_namespace_rootnode("dcp","http://thermal.cnde.iastate.edu/datacollect/provenance")
                #sys.stderr.write("nsmap=%s\n" % (output.doc.getroot().nsmap))
                pass
            finally:
                output.unlock_rw()
                pass
            pass

        # transfer namespace mapping from prxdoc to output to the extent possible
        # (and store in memory for our use)
        # print prxdoc
        # print  prxdoc.getroot()
        # print  prxdoc.getroot().nsmap
        output.lock_rw()
        try: 
            prxdocmap=prxdoc.getroot().nsmap
            for nspre in prxdocmap.keys():
                if nspre is not None:
                    output.merge_namespace(nspre,prxdocmap[nspre])
                    output.suggest_namespace_rootnode(nspre,prxdocmap[nspre])
                    pass
                pass
            pass
        finally:
            output.unlock_rw()
            pass
        ## look for dc:reldest element to find working location
        #reldestpath=prxdoc.xpathsinglestr("prx:reldestpath",default="dc:summary/dc:reldest")
        #destdir=os.path.join(inputdir,output.xpathsinglestr(reldestpath,default="."))

        
    
        # Create our <dcp:process> element
        outputroot=output.getroot()
        process_el=output.addelement(outputroot,"dcp:process")
        wcb_el=output.addelement(process_el,"dcp:wascontrolledby")
        prxfile_el=provenance.reference_file(output,wcb_el,"dcp:prxfile",outputroot,prxfilehref,"info")
        output.setattr(prxfile_el,"dcp:timestamp",datetime.datetime.fromtimestamp(os.path.getmtime(prxfilehref.getpath()),dg_timestamp.UTC()).isoformat())
        
        provenance.write_timestamp(output,process_el,"dcp:starttimestamp",overall_starttime)
        provenance.write_process_info(output,process_el)
        provenance.write_input_file(output,process_el,inputfilehref)
    
        # Give our dcp:process element a unique hash   (hash is used for distinguishing adjacent process elements)
        provenance.set_hash(output,process_el,process_el)
    
        # Get a path to our dcp:process element, now that we have defined its uuid
        processpath=output.savepath(process_el)
    
        if copiedfile:
            # Add a sub dcp:process representing file copy action
            cfprocess_el=output.addelement(process_el,"dcp:process")
            # have dcp:used point to the input file we copied from 
            provenance.reference_file(output,cfprocess_el,"dcp:used",outputroot,inputfilehref,warnlevel="warning")
            provenance.write_action(output,cfprocess_el,"_copy_input_file")
            provenance.write_timestamp(output,cfprocess_el,"dcp:starttimestamp",cf_starttime)
            provenance.write_timestamp(output,cfprocess_el,"dcp:finishtimestamp")
        
            # hash this new dcp:process tag
            copiedfile_uuid=provenance.set_hash(output,process_el,cfprocess_el)

            # Mark all elements in tree as being generated by this copy process
            provenance.add_generatedby_to_tree(output,outputroot,process_el,copiedfile_uuid)
            pass


        output.unlock_rw()  # free output lock

        for step in steps:   # OK to pass step as element because prxdoc is strictly in memory
            print("\nProcessing step %s on URL %s." % (dc_process_common.getstepname(prxdoc,step),outputfilehref.absurl())) 

            procstep(scriptdirhref,prxdoc,output,step,processpath,elementmatch,elementmatch_nsmap,filters,cwd_fd,inputfilehref,debugmode,ipythonmodelist)
            pass

        output.shouldbeunlocked()

        # Write final timestamp
        output.lock_rw()
        process_el=output.restorepath(processpath)
        provenance.write_timestamp(output,process_el,"dcp:finishtimestamp")
        output.unlock_rw()  # free output lock
        pass

    pass
