from __future__ import print_function

import sys
import os
import os.path
import posixpath
import socket
import copy
import collections
import inspect
import numbers
import traceback
import collections
import ast
import hashlib
import fnmatch
import binascii
from distutils.version import LooseVersion

from lxml import etree

try:
    from cStringIO import StringIO
    pass
except ImportError:
    from io import StringIO
    pass

from io import BytesIO

import shutil
import datetime
import subprocess

try:
    # py2.x
    from urllib import pathname2url
    from urllib import url2pathname
    from urllib import quote
    from urllib import unquote
    from urlparse import urlparse
    from urlparse import urlunparse
    from urlparse import urljoin    
    pass
except ImportError:
    # py3.x
    from urllib.request import pathname2url
    from urllib.request import url2pathname
    from urllib.parse import quote
    from urllib.parse import unquote
    from urllib.parse import urlparse
    from urllib.parse import urlunparse
    from urllib.parse import urljoin
    pass


try: 
    import builtins  # python3
    pass
except ImportError: 
    import __builtin__ as builtins # python2
    pass

if not hasattr(builtins,"unicode"):
    # python3
    unicode=str
    pass

if not hasattr(builtins,"basestring"):
    # python3
    basestring=str
    pass

# import dg_units

from . import timestamp
from . import canonicalize_path
from .canonicalize_path import etxpath2human

from . import dc_value as dcv
from . import provenance as provenance
from . import xmldoc
from . import processtrak_prxdoc
from . import processtrak_stepparam
from . import processtrak_common


try:
    from pkg_resources import resource_string
    from pkg_resources import iter_entry_points
    pass
except TypeError:
    # mask lack of pkg_resources when we are running under pychecker
    def resource_string(x,y):
        raise IOError("Could not import pkg_resources")
    pass


try: 
    __install_prefix__=resource_string(__name__, 'install_prefix.txt').decode('utf-8')
    pass
except IOError: 
    sys.stderr.write("processtrak: error reading install_prefix.txt. Assuming /usr/local.\n")
    __install_prefix__="/usr/local"
    pass

def getstepurlpath():
    return [ pathname2url(os.path.join(__install_prefix__,"share","limatix","pt_steps")) ]

def get_stephrefpaths(primary=False):
    # obtain step path by merging lists generated by limatix.datacollect2.stepurlpath entrypoints.
    # primary=True limits it to just the main /usr/share/limatix/pt_steps or similar
    
    steppath = []
    for entrypoint in iter_entry_points("limatix.processtrak.step_url_search_path"):
        steppathfunc=entrypoint.load()
        add_to_steppath = steppathfunc()
        if isinstance(add_to_steppath,basestring):
            sys.stderr.write("limatix.processtrak_procstep: Error enumerating limatix.datacollect2.ptstepurlpath entry points: Got string from %s:%s; expected list or tuple\n" % (entrypoint.module_name,entrypoint.name))
            continue
        
        if not primary or entrypoint.name=="limatix.share.pt_steps":            
            steppath.extend(add_to_steppath)
            pass
        pass
    
    stephrefpaths=[ dcv.hrefvalue(stepurl) if stepurl.endswith(posixpath.sep) else dcv.hrefvalue(stepurl+posixpath.sep) for stepurl in steppath ]
    return stephrefpaths
    


def find_script_in_path(contexthref,scriptname):
    #if os.path.exists(os.path.join(contexthref.getpath(),scriptname)):
    #    print("WARNING: direct paths to scripts should be specified with <script xlink:href=\"...\"/>. Use the name=\"...\" attribute only for scripts to be found in the script search path")
    #    pass
    
    #if posixpath.isabs(scriptname):
    #    return dcv.hrefvalue(quote(scriptname),contexthref=dcv.hrefvalue("./"))
    #
    #if posixpath.pathsep in scriptname:
    #    return dcv.hrefvalue(quote(scriptname),contexthref=contexthref)

    stephrefpaths=get_stephrefpaths()
    
    for tryhrefpath in stephrefpaths:

        candidate=dcv.hrefvalue(quote(scriptname),contexthref=tryhrefpath)
        if os.path.exists(candidate.getpath()):
            return candidate
        pass
    
    raise IOError("Could not find script %s in path %s" % (scriptname,unicode([ searchhref.humanurl() for searchhref in stephrefpaths ])))


def procstepmatlab(*args,**kwargs):
    # *** output should be rwlock'd exactly ONCE when this is called
    # *** Output will be rwlock'd exactly ONCE on return
    #     (but may have been unlocked in the interim)
    raise NotImplementedError("procstepmatlab")

def procsteppython_do_run(stepglobals,runfunc,argkw,ipythonmodelist,action,scripthref,pycode_text,pycode_lineno):

    if not ipythonmodelist[0]:
        resultdict=runfunc(**argkw)
        return resultdict
    else:
        # ipython mode
        # in-process kernel, a-la https://raw.githubusercontent.com/ipython/ipython/master/examples/Embedding/inprocess_qtconsole.py

        ## Set PyQt4 API version to 2 and import it -- required for ipython compatibility
        #import sip
        #sip.setapi('QVariant', 2)
        #sip.setapi('QString', 2)
        #sip.setapi('QDateTime', 2)
        #sip.setapi('QDate', 2)
        #sip.setapi('QTextStream', 2)
        #sip.setapi('QTime', 2)
        #sip.setapi('QUrl', 2)
        #from PyQt4 import QtGui   # force IPython to use PyQt4 by importing it first

        # RHEL6 compatibility  -- if running under Python 2.6, just import IPython, get PyQt4
        if sys.version_info < (2,7):
            from IPython.qt.console.rich_ipython_widget import RichIPythonWidget
            from IPython.qt.inprocess import QtInProcessKernelManager
            pass
        else: 

            # Under more recent OS's: Make matplotlib use PySide
            # http://stackoverflow.com/questions/6723527/getting-pyside-to-work-with-matplotlib
            import matplotlib
            matplotlib.use('Qt4Agg')
            matplotlib.rcParams['backend.qt4']='PySide'
            pass

        import IPython
        from IPython.core.interactiveshell import DummyMod

        if LooseVersion(IPython.__version__) >= LooseVersion('4.0.0'):
            # Recent Jupyter/ipython: Import from qtconsole
            # Force PySide bindings
            import PySide.QtCore
            from qtconsole.qt import QtGui
            from qtconsole.inprocess import QtInProcessKernelManager

            # Obtain the running QApplication instance
            app=QtGui.QApplication.instance()
            if app is None:
                # Start our own if necessary
                app=QtGui.QApplication([])
                pass
            
            pass
        else:
            from IPython.qt.inprocess import QtInProcessKernelManager
            from IPython.lib import guisupport
            app = guisupport.get_app_qt4() 

            pass
        
        kernel_manager = QtInProcessKernelManager()
        kernel_manager.start_kernel()
        kernel = kernel_manager.kernel
        kernel.gui = 'qt4'

        #sys.stderr.write("id(stepglobals)=%d" % (id(stepglobals)))

        # Make ipython use our globals as its global dictionary
        # ... but first keep a backup
        stepglobalsbackup=copy.copy(stepglobals)
        
        (kernel.user_module,kernel.user_ns)=kernel.shell.prepare_user_module(user_ns=stepglobals)
        
        # Should we attempt to run the function here?
        
        # (gui, backend) = kernel.shell.enable_matplotlib("qt4") #,import_all=False) # (args.gui, import_all=import_all)
        (gui, backend, clobbered) = kernel.shell.enable_pylab("qt4",import_all=False) # (args.gui, import_all=import_all)

        # kernel.shell.push(stepglobals) # provide globals as variables -- no longer necessary as it's using our namespace already
        
        kernel.shell.push(argkw) # provide arguments as variables
        
        kernel.shell.push({"kernel":kernel},interactive=False) # provide kernel for debugging purposes

        kernel_client = kernel_manager.client()
        kernel_client.start_channels()
        abort_requested_list=[False] # encapsulated in a list to make it mutable

        def stop():
            control.hide()
            kernel_client.stop_channels()
            kernel_manager.shutdown_kernel()
            app.exit()
            pass

        def abort():
            # simple exit doesn't work. See http://stackoverflow.com/questions/1527689/exit-from-ipython
            # too bad this doesn't work right now!!!
            class Quitter(object):
                def __repr__(self):
                    sys.exit()
                pass
            kernel.shell.push({"quitter":Quitter()})
            kernel.shell.ex("quitter")

            stop()
            abort_requested_list.pop()
            abort_requested_list.append(True)
            pass
        
        if pycode_text is None:            
            kernel.shell.write("\n\nExecute %s/%s\n" % (scripthref.getpath(),runfunc.__name__))
            pass
        else: 
            kernel.shell.write("\n\nExecute %s/%s/%s\n" % (scripthref.getpath(),action,runfunc.__name__))
            pass

        kernel.shell.write("Assign return value to \"ret\" and press Ctrl-D\n")
        kernel.shell.write("Set cont=True to disable interactive mode\n")
        # kernel.shell.write("call abort() to exit\n")

        if LooseVersion(IPython.__version__) >= LooseVersion('4.0.0'):
            # Recent Jupyter/ipython: Import from qtconsole
            from qtconsole.rich_jupyter_widget import RichJupyterWidget as RichIPythonWidget
            pass
        else: 
            from IPython.qt.console.rich_ipython_widget import RichIPythonWidget
            pass
        
        control = RichIPythonWidget()
        control.kernel_manager = kernel_manager
        control.kernel_client = kernel_client
        control.exit_requested.connect(stop)
        control.show()


        #sys.stderr.write("lines=%s\n" % (str(lines)))
        #sys.stderr.write("lines[0]=%s\n" % (str(lines[0])))

        
        try:
            if pycode_text is None:
                (lines,startinglineno)=inspect.getsourcelines(runfunc)
                
                assert(lines[0].startswith("def")) # first line of function is the defining line

                # Preparse to figure out how many lines are part of def
                preparse=ast.parse("".join(lines),filename=scripthref.getpath(),mode='exec')
                assert isinstance(preparse.body[0],ast.FunctionDef)
                assert(preparse.body[0].lineno==1) # Def statement should start on line "1"
                firstbodyline = preparse.body[0].body[0].lineno
                lines_to_delete = firstbodyline - 2

                del lines[:lines_to_delete] # remove def line, leading comments, etc. 
                lines.insert(0,"if 1:\n") # allow function to be indented
                runfunc_syntaxtree=ast.parse("".join(lines), filename=scripthref.getpath(), mode='exec') # BUG: Should set dont_inherit parameter and properly determine which __future__ import flags should be passed

                # fixup line numbers
                for syntreenode in ast.walk(runfunc_syntaxtree):
                    if hasattr(syntreenode,"lineno"):
                        syntreenode.lineno+=startinglineno+lines_to_delete-1-1
                        pass
                    pass

                # runfunc_syntaxtree should consist of the if statement we just added
                # use _fields attribute to look up fields of an AST element
                # (e.g. test, body, orelse for IF)
                # then those fields can be accessed directly
                assert(len(runfunc_syntaxtree.body)==1)
                code_container=runfunc_syntaxtree.body[0]
                assert(isinstance(code_container,ast.If)) # code_container is the if statement we just wrote
                
                kernel.shell.push({"runfunc_syntaxtree": runfunc_syntaxtree},interactive=False) # provide processed syntax tree for debugging purposes

                pass
            else : 
                fullsyntaxtree=ast.parse(pycode_text) # BUG: Should set dont_inherit parameter and properly determine which __future__ import flags should be passed
                # fixup line numbers
                for syntreenode in ast.walk(fullsyntaxtree):
                    if hasattr(syntreenode,"lineno"):
                        syntreenode.lineno+=pycode_lineno-1
                        pass
                    pass
                code_container=None
                for codeelement in fullsyntaxtree.body:
                    if isinstance(codeelement,ast.FunctionDef):
                        if codeelement.name==runfunc.__name__:
                            code_container=codeelement
                            runfunc_syntaxtree=codeelement
                            pass
                        pass
                    
                    pass
                if code_container is None: 
                    raise ValueError("Couldn't find code for %s for ipython execution" % (runfunc.__name__)) 

                kernel.shell.push({"fullsyntaxtree": fullsyntaxtree},interactive=False) # provide full syntax tree for debugging purposes
                
                pass

            # identify global variables from runfunc_syntaxtree
            globalvars=set()
            for treeelem in ast.walk(runfunc_syntaxtree):
                if isinstance(treeelem,ast.Global):
                    globalvars=globalvars.union(treeelem.names)
                    pass
                pass
            
            
            
            kernel.shell.push({"abort": abort}) # provide abort function
            kernel.shell.push({"cont": False}) # continue defaults to False



            
            returnstatement=code_container.body[-1]
            if isinstance(returnstatement,ast.Return):
                # last statement is a return statement!
                # Create assign statement that assigns 
                # the result to ret
                retassign=ast.Assign(targets=[ast.Name(id="ret",ctx=ast.Store(),lineno=returnstatement.lineno,col_offset=returnstatement.col_offset)],value=returnstatement.value,lineno=returnstatement.lineno,col_offset=returnstatement.col_offset)
                del code_container.body[-1] # remove returnstatement
                code_container.body.append(retassign) # add assignment
                pass
            

            runfunc_lines=code_container.body

            kernel.shell.push({"runfunc_lines": runfunc_lines,"scripthref": scripthref},interactive=False) # provide processed syntax tree for debugging purposes
            
            # kernel.shell.run_code(compile("kernel.shell.run_ast_nodes(runfunc_lines,scriptpath,interactivity='all')","None","exec"))
            if LooseVersion(IPython.__version__) >= LooseVersion('4.0.0'):
                # Recent Jupyter/ipython: Import from qtconsole
                from qtconsole.inprocess import QtCore
                pass
            else: 
                from IPython.qt.inprocess import QtCore
                pass
            QTimer=QtCore.QTimer

            def showret():
                control.execute("ret")
                pass
                
            
            def runcode():
                control.execute("kernel.shell.run_ast_nodes(runfunc_lines,scripthref.getpath(),interactivity='none')")
                # QTimer.singleShot(25,showret) # get callback 25ms into main loop
                # showret disabled because it prevents you from running the 
                # debugger in post-mortem mode to troubleshoot an exception:
                # import pdb; pdb.pm() 
                pass
            
            QTimer.singleShot(25,runcode) # get callback 25ms into main loop
            # control.execute("kernel.shell.run_ast_nodes(runfunc_lines,scripthref.getpath(),interactivity='none')")

            pass
        except:
            (exctype, excvalue) = sys.exc_info()[:2] 
            sys.stderr.write("%s while attempting to prepare URL %s code for interactive execution: %s\n" % (exctype.__name__,scripthref.absurl(),str(excvalue)))
            traceback.print_exc()
            raise




        if LooseVersion(IPython.__version__) >= LooseVersion('4.0.0'):
            # Recent Jupyter/ipython: Import from qtconsole
            app.exec_()
            pass
        else:
            # Old ipython
            guisupport.start_event_loop_qt4(app)
            pass
        
        if abort_requested_list[0]:
            pass
        
        if kernel.shell.ev("cont"):
            # cont==True -> disable interactive mode
            ipythonmodelist.pop()
            ipythonmodelist.append(False)
            pass

        try : 
            retval = kernel.shell.ev("ret") # Assign result dictionary to "ret" variable
            pass
        except NameError: # if ret not assigned, return {}
            retval = {}
            pass
        
        # Performing this execution changed values in stepglobals
        # but it should have only done that for variables specified
        # as 'global' in the function.

        # So: Update our backup of the value of stepglobals,
        #     according to the specified globals, and
        #     replace stepglobals with that updated backup

        
        stepglobalsbackup.update(dict([ (varname,stepglobals[varname]) for varname in globalvars]))
        stepglobals.clear()
        stepglobals.update(stepglobalsbackup)

        return retval
    
    pass

def resultelementfromdict(output,resultdict):
    # resultdict can either be a dict
    # or a list/tuple of (key,element) pairs. 
    # tuple use case is so that what would otherwise be a key
    # can itself contain a dictionary of attributes

    resultelementdoc=xmldoc.xmldoc.newdoc("resultelement",nsmap=output.nsmap,contexthref=output.getcontexthref())
    
    applyresultdict(resultelementdoc,None,None,resultelementdoc.getroot(),resultdict)
    return resultelementdoc


def applyresultdict_dissectresult(output,element,resultname,resultitem):

    attrdict={}
    if isinstance(resultname,tuple):
        # if result is a tuple, then treat first element 
        # of tuple as actual name, second element as attribute dictionary, 
        assert(len(resultname)==2)
        attrdict.update(resultname[1])
        name=resultname[0]
        pass
    else: 
        name=resultname
        pass
    
    
    # split name by '/' like an xpath... treat all but the trailing
    # part as an xpath context
    if "/" in name: 
        (tagpath,tagname)=name.rsplit("/",1)
        tagpatheval=output.xpathsinglecontext(element,tagpath,namespaces=output.namespaces)
        pass
    else:
        tagname=name
        tagpatheval=element
        pass
    

    if isinstance(resultitem,tuple):
        # if result is a tuple, then treat first element 
        # of tuple as an attribute dictionary, second
        # element as value object
        assert(len(resultitem)==2)
        attrdict.update(resultitem[0])
        resultvalue=resultitem[1]
        pass
    else: 
        resultvalue=resultitem
        pass
    
    
    return (tagname,tagpatheval,attrdict,resultvalue)


def applyresultdict(output,prxdoc,steptag,element,resultdict):
    # resultdict can either be a dict
    # or a list/tuple of (key,element) pairs. 
    # tuple use case is so that what would otherwise be a key
    # can itself contain a dictionary of attributes

    
    if isinstance(resultdict,collections.Mapping):
        # dictionary or dictionary-like: 
        # Convert to list of (key,element) pairs
        resultlist=[ (key,resultdict[key]) for key in resultdict.keys() ]
        pass
    else:
        # list or tuple
        resultlist=resultdict
        pass

    # Go through results...
    for (resultname,resultitem) in resultlist: 

        (tagname,tagpatheval,attrdict,resultvalue)=applyresultdict_dissectresult(output,element,resultname,resultitem)
        
        # ... and remove preexisting elements if present
        # (We do this first because otherwise there is the potential 
        # for provenance mixup between the results we are destroying 
        # and the ones we are about to generated) 
        oldelements=output.children(tagpatheval,tagname,noprovenanceupdate=True)
        for oldelement in oldelements:
            # do the requested attributes match?
            attrmatch=True

            for attrname in attrdict:
                if not(output.hasattr(oldelement,attrname)) or output.getattr(oldelement,attrname)!=attrdict[attrname]:
                    attrmatch=False
                    break
                pass
            
            if attrmatch: 
                # no attribute mismatch... remove element
                output.removeelement(oldelement)
                pass
            pass

        pass

    # Now go through again and generate the elements 
    # Go through results...
    for (resultname,resultitem) in resultlist: 

        (tagname,tagpatheval,attrdict,resultvalue)=applyresultdict_dissectresult(output,element,resultname,resultitem)

        if not ":" in tagname and None in output.nsmap:
            sys.stderr.write("processtrak_procstep.applyresultdict() WARNING: Results from processtrak\nsteps should always specify the XML namespace of result tags\nwhen a default namespace is set. Otherwise they get placed in\nthe default namespace, but not replaced on the next run.\n")
            pass
        
        
        # Create new element according to type
        # sys.stderr.write("resultdict=%s\n" % (str(resultdict))) 
        if isinstance(resultvalue,numbers.Number):
            newel=output.addsimpleelement(tagpatheval,tagname,(resultvalue,))
            pass
        elif isinstance(resultvalue,dcv.value):
            newel=output.addelement(tagpatheval,tagname)
            resultvalue.xmlrepr(output,newel)
            pass
        elif isinstance(resultvalue,basestring):
            newel=output.addelement(tagpatheval,tagname)
            output.settext(newel,resultvalue)
            pass
        elif isinstance(resultvalue,xmldoc.xmldoc):            
            newel=output.addelement(tagpatheval,tagname)
            # copy tree from resultvalue
            resultroot=copy.deepcopy(resultvalue.doc.getroot())
            newel[:]=resultroot[:]
            for attrname in resultroot.attrib:
                newel.attrib[attrname]=resultroot.attrib[attrname]
                pass
            newel.text=resultroot.text
            newel.tail=resultroot.tail

            # mark provenance of sub-elements
            for subel in newel.iterdescendants():
                provenance.elementgenerated(output,subel)
                pass
            pass
        else :
            if prxdoc is not None and steptag is not None:
                raise ValueError("step %s gave unknown result type %s for %s" % (prxdoc.tostring(steptag),unicode(resultvalue.__class__),resultname))
            else: 
                raise ValueError("step gave unknown result type %s for %s" % (unicode(resultvalue.__class__),resultname))
            pass
        # add attributes to newel
        for attrname in attrdict:
            output.setattr(newel,attrname,attrdict[attrname])
            pass

        pass
    pass

def procsteppython_runelement(output,prxdoc,prxnsmap,steptag,rootprocesspath,stepprocesspath,elementpath,uniquematches,stepglobals,argnames,argsdefaults,params,inputfilehref,ipythonmodelist,execfunc,action,scripthref,pycode_text,pycode_lineno):
    # *** output should be rwlock'd exactly ONCE when this is called
    # *** Output will be rwlock'd exactly ONCE on return
    #     (but may have been unlocked in the interim)



    element=output.restorepath(elementpath)

    print("Element %s\r" % (dcv.hrefvalue.fromelement(output,element).humanurl()),end="\r")
    #print("Element %s\r" % (canonicalize_path.getelementhumanxpath(output,element,nsmap=prxnsmap)),end="\r")
    sys.stdout.flush()

    rootprocess_el=output.restorepath(rootprocesspath)
    
    provenance.starttrackprovenance()
    try : # try-catch-finally block for starttrackprovenance()
        
        argkw={}
        
        #sys.stderr.write("argnames=%s\n" % (str(argnames)))
        #sys.stderr.write("params.keys()=%s\n" % (str(params.keys())))
        
        for argname in argnames:
            # argname often has a underscore-separated type suffix
            if "_" in argname:
                (argnamebase,argnametype)=argname.rsplit("_",1)
                pass
            else:
                argnamebase=None
                pass
            
            if argname in params:
                # calling evaluate tracks provenance!
                # returns XML element for auto-params or xpaths
                # returns dc_value for fixed numeric params
                # returns string for fixed string params
                argkw[argname]=processtrak_stepparam.evaluate_params(params,argname,None,output,element,inputfilehref)
                pass
            elif argnamebase in params:
                argkw[argname]=processtrak_stepparam.evaluate_params(params,argnamebase,argnametype,output,element,inputfilehref)
                
            elif argname=="_xmldoc":  # _xmldoc parameter gets output XML document
                argkw[argname]=output         # supply output XML document
                pass
            elif argname=="_prxdoc":  # _xmldoc parameter gets output XML document
                argkw[argname]=prxdoc         # supply output XML document
                pass
            elif argname=="_step":  # _xmldoc parameter gets output XML document
                argkw[argname]=steptag         # supply output XML document
                pass
            elif argname=="_uniquematches":  # _uniquematches parameter gets list of elements matching the key of the <prx:uniquematch> and corresponding to this particular element
                argkw[argname]=uniquematches   # supply uniquematches list
                
                pass
            elif argname=="_inputfilename":  # _inputfilename parameter gets unquoted name (but not path) of input file
                argkw[argname]=inputfilehref.get_bare_unquoted_filename()
                pass
            elif argname=="_element" or argname=="_tag": # _element (formerly _tag) parameter gets current tag we are operating on
                argkw[argname]=element
                pass
            elif argname=="_dest_href":
                # Get hrefvalue pointing at destination directory, where
                # files should be written
                destlist=output.xpath("dc:summary/dc:dest",namespaces=processtrak_common.prx_nsmap)
                argkw[argname]=None
                if len(destlist)==1:
                    argkw[argname]=dcv.hrefvalue.fromxml(output,destlist[0])
                    pass
                pass
            else :
                # Try to extract it from a document tag
                try : 
                    argkw[argname]=processtrak_stepparam.findparam(prxnsmap,output,element,argname)
                    pass
                except NameError:
                    # if there is a default, use that
                    if argname in argsdefaults:
                        argkw[argname]=argsdefaults[argname]
                        pass
                    else:
                        raise  # Let user know we can't find this!
                    pass
                pass
            pass
        
        # unlock XML file if "rununlocked" so parallel processes can mess with it

        #os.chdir(destdir) # CD into destination directory
        try :  # try... catch.. finally.. block for changed directory
            if execfunc.__name__.endswith("unlocked"): 
                if  "_tag" in argnames or "_element" in argnames or "_uniquematches" in argnames:
                    # can't supply element if lock is released
                    raise ValueError("Python function for step %s cannot be rununlocked because it requires XML element parameter(s)" % (processtrak_prxdoc.getstepname(prxdoc,steptag)))
                if uniquematches is not None:
                    # prx:uniquematch not compatible with rununlocked()
                    raise ValueError("<prx:uniquematch> is incompatible with rununlocked() in step %s." % (processtrak_prxdoc.getstepname(prxdoc,steptag)))
                
                output.unlock_rw() # release output lock 
                try: 
                    resultdict=procsteppython_do_run(stepglobals,execfunc,argkw,ipythonmodelist,action,scripthref,pycode_text,pycode_lineno)
                    pass
                finally: 
                    output.lock_rw() # secure output lock ... otherwise
                    # an exception would be handled several levels above
                    # which assumes we are locked. 
                    pass

                del rootprocess_el
                element=output.restorepath(elementpath)
                
                pass
            else: 
                resultdict=procsteppython_do_run(stepglobals,execfunc,argkw,ipythonmodelist,action,scripthref,pycode_text,pycode_lineno)
                # print("processtrak: print_current_used() after do_run of %s" % (str(execfunc)))
                # provenance.print_current_used()
                
            
                output.should_be_rwlocked_once() # Verify that after running, the output is still locked exactly once
                element=output.restorepath(elementpath) # run function may have unlocked output temporarily so we need to restore the element from its path
                pass
            pass
        except: 
            raise
        finally: 
            #os.fchdir(cwd_fd) # CD back to regular directory
            pass
        
        if resultdict is None: 
            resultdict={}  # no results provided
            pass
        

        applyresultdict(output,prxdoc,steptag,element,resultdict)
    
        pass
    except:
        raise
    finally:
        # print("processtrak: print_current_used()")
        # provenance.print_current_used()

        (modified_elements,referenced_elements)=provenance.finishtrackprovenance()
        pass

    # exit with output still in locked state. 
    return (modified_elements,referenced_elements)
    

def procstep_elementmatch_elementpath_generator(prxdoc,output,steptag,elementmatch,elementmatch_nsmap,uniquematchel,filters):
    elmn_copy=copy.copy(elementmatch_nsmap)
    if None in elmn_copy:
        del elmn_copy[None]  # Can not pass None entry
        pass
    # Add filters to elementmatch
    
    for elementfilter in filters:
        elementmatch+="[%s]" % (elementfilter)
        pass

    # Search for matching elements

    # sys.stderr.write("elementmatch=%s\n" % (elementmatch))
    try: 
        elements=output.xpath(elementmatch,namespaces=elmn_copy,variables={"filepath":output.filehref.getpath(),"filename":os.path.split(output.filehref.getpath())[1]})
        pass
    except etree.XPathEvalError:
        raise ValueError("XPathEvalError evaluating xpath %s on url %s in step %s" % (elementmatch,output.filehref.absurl(),processtrak_prxdoc.getstepname(prxdoc,steptag)))
    
    elementpaths=[ output.savepath(element) for element in elements]

    for elementpath in elementpaths:
        yield (elementpath,None)  # return element paths one-by-one

    pass

def canonxmlrepr(element):
    """Return copy of element tree and canonicalized 
    string representation"""
    
    elcopy = copy.deepcopy(element)
    provenance.strip_provenance_attributes(elcopy) # Provenance is not part of the canonical representation

    
    et=etree.ElementTree(elcopy)
    fh=BytesIO()
    et.write_c14n(fh,exclusive=True,with_comments=False)
    fh.seek(0)
    canonstr=fh.read().decode('utf-8')
    fh.close()
    return (elcopy,canonstr)

def grandchildren_with_tag(child,tagnames):
    """Return children of child that have tag names in 
    the given set of tag names"""
    ret=[]
    for grandchild in child.iterchildren():
        if grandchild.tag in tagnames:
            ret.append(grandchild)
            pass
        pass
    return ret
    
def procstep_uniquematch_element_generator_nofilters(prxdoc,output,steptag,elementmatch,elementmatch_nsmap,uniquematchel):
    
    # Search for matching elements

    # sys.stderr.write("elementmatch=%s\n" % (elementmatch))
    if not "key" in uniquematchel.attrib:
        raise ValueError("Step %s: <prx:uniquematch> element has no \"key\" attribute" % (processtrak_prxdoc.getstepname(prxdoc,steptag)))
    

    if not "parent" in uniquematchel.attrib:
        raise ValueError("Step %s: <prx:uniquematch> element has no \"parent\" attribute" % (processtrak_prxdoc.getstepname(prxdoc,steptag)))
    

    key_criterion=uniquematchel.attrib["key"]
    parentxpath = uniquematchel.attrib["parent"]

    
    umn_copy=copy.copy(uniquematchel.nsmap)
    if None in umn_copy:
        del umn_copy[None]  # Can not pass None entry
        pass
    
    try: 
        key_elements=output.xpath(key_criterion,namespaces=umn_copy,variables={"filepath":output.filehref.getpath(),"filename":os.path.split(output.filehref.getpath())[1]})
        pass
    except etree.XPathEvalError:
        raise ValueError("XPathEvalError evaluating xpath %s on url %s in step %s" % (key_criterion,output.filehref.absurl(),processtrak_prxdoc.getstepname(prxdoc,steptag)))


    if len(key_elements)==0:
        sys.stderr.write("Warning: step %s: no element match key for <prx:uniquematch> for output href %s\n" % (processtrak_prxdoc.getstepname(prxdoc,steptag),output.get_filehref().absurl()))
        pass
    
    try:
        parent_elements=output.xpath(parentxpath,namespaces=umn_copy,variables={"filepath":output.filehref.getpath(),"filename":os.path.split(output.filehref.getpath())[1]})
        pass
    except etree.XPathEvalError:
        raise ValueError("XPathEvalError evaluating xpath %s on url %s in step %s" % (parentxpath,output.filehref.absurl(),processtrak_prxdoc.getstepname(prxdoc,steptag)))
    
    if len(parent_elements)!=1:
        raise ValueError("Step %s: <prx:uniquematch> parent must match exactly one element (%d found)" % (processtrak_prxdoc.getstepname(prxdoc,steptag),len(parent_elements)))

    grandchild_tagnames=set()
    unique_dict=collections.OrderedDict() # Dictionary by canonical text of element copies
    elementlist_dict={}  # Dictionary by canonical text of list of original elements 
    for element in key_elements:
        # Canonicalize each element by putting it into an element tree
        # and doing canonical serialization
        (elcopy,canonstr)=canonxmlrepr(element)
        if canonstr not in unique_dict:
            unique_dict[canonstr]=elcopy
            elementlist_dict[canonstr]=[]
            pass
        elementlist_dict[canonstr].append(element) # Save original element on list
        grandchild_tagnames.add(elcopy.tag)
        pass



    
    uniquematch_children = prxdoc.xpathcontext(uniquematchel,"*")
    if len(uniquematch_children) != 1:
        raise ValueError("Step %s: <prx:uniquematch> element must have exactly one child (%d found)" % (processtrak_prxdoc.getstepname(prxdoc,steptag),len(uniquematch_children)))
        
    childtag=uniquematch_children[0].tag

    # Find all pre-existing children of the desired parent element
    # that match this tag
    
    candidate_children=[ (child,grandchildren_with_tag(child,grandchild_tagnames)) for child in parent_elements[0].iterchildren() if child.tag==childtag ]

    candidate_grandchildren=[ (child,grandchildren) for (child,grandchildren) in candidate_children if len(grandchildren) > 0 ]

    candidate_children_by_canon_grandchild={ }
    for (child,grandchildren) in candidate_grandchildren:
        for grandchild in grandchildren:
            candidate_children_by_canon_grandchild[canonxmlrepr(grandchild)[1]]=child
            pass
        pass

    # Go through our unique_dict and see if tags already exist
    for canonstr in unique_dict:
        if canonstr in candidate_children_by_canon_grandchild:
            # Use pre-existing element
            yield (candidate_children_by_canon_grandchild[canonstr],elementlist_dict[canonstr])
        else:
            # No such child already exists
            # .. create it
            
            newchild = etree.Element(childtag,nsmap=parent_elements[0].nsmap)

            # ... Give it the characteristic element
            elcopy=unique_dict[canonstr]
            newchild.append(elcopy)

            # Add it to the parent, marking our provenance
            parent_elements[0].append(newchild)
            provenance.elementgenerated(output,elcopy)
            provenance.elementgenerated(output,newchild)
            output.modified=True

            # ... and use it!
            yield (newchild,elementlist_dict[canonstr])
        pass


    pass

def procstep_uniquematch_elementpath_generator(prxdoc,output,steptag,elementmatch,elementmatch_nsmap,uniquematchel,filters):

    matchcriterion="."
    for elementfilter in filters:
        matchcriterion+="[%s]" % (elementfilter)
        pass
    
    
    for (unfiltered,unfiltered_elementmatchlist) in procstep_uniquematch_element_generator_nofilters(prxdoc,output,steptag,elementmatch,elementmatch_nsmap,uniquematchel):
        resultlist = output.xpathcontext(unfiltered,matchcriterion)
        if len(resultlist) > 0:
            assert(len(resultlist)==1) # Shouldn't be possible to get multiple elements
            yield (output.savepath(resultlist[0]),unfiltered_elementmatchlist)
            pass
        
        pass
    pass




def procsteppython_execfunc(scripthref,pycode_text,pycode_lineno,prxdoc,prxnsmap,output,steptag,scripttag,rootprocesspath,stepprocesspath,stepglobals,elementmatch,elementmatch_nsmap,uniquematchel,params,filters,inputfilehref,debugmode,stdouthandler,stderrhandler,ipythonmodelist,execfunc,action):
    
    if hasattr(inspect,"getfullargspec"):
        getargspecfunc = inspect.getfullargspec # python3
        pass
    else:
        getargspecfunc = inspect.getargspec # python 2
        pass
    
    (argnames, varargs, keywords, defaults)=getargspecfunc(execfunc)        
    
    argsdefaults={}
    if defaults is not None:
        numdefaults=len(defaults)
        argsdefaults=dict(zip(argnames[-numdefaults:],defaults))
        # argsdefaults is a dictionary by argname of default values.
        pass


    if uniquematchel is not None:
        procstep_elementpath_generator = procstep_uniquematch_elementpath_generator
        pass
    else:
        procstep_elementpath_generator = procstep_elementmatch_elementpath_generator
        pass
    

    # output.unlock_rw() # release output lock

    matchcnt=0

    # Loop over each matching element
    for (elementpath,uniquematches) in procstep_elementpath_generator(prxdoc,output,steptag,elementmatch,elementmatch_nsmap,uniquematchel,filters):
        # elementpath is the path to the element we have found that we are
        # supposed to be operating on
        # uniquematches, if it is not None, and for is a list of elements
        # that matched the key of the <prx:uniquematch> element
        # giving rise to this element. 

        
        matchcnt+=1
        modified_elements=set([])
        referenced_elements=set([])

        el_starttime=timestamp.now().isoformat()
        
        # Capture python stdio/stderr 
        errcapt=StringIO()
        stdouthandler.set_dest(errcapt)
        stderrhandler.set_dest(errcapt)

        status="success"

        output.should_be_rwlocked_once()

        try : 
            (modified_elements,referenced_elements)=procsteppython_runelement(output,prxdoc,prxnsmap,steptag,rootprocesspath,stepprocesspath,elementpath,uniquematches,stepglobals,argnames,argsdefaults,params,inputfilehref,ipythonmodelist,execfunc,action,scripthref,pycode_text,pycode_lineno)
            pass
        except KeyboardInterrupt: 
            # Don't want to hold off keyboard interrupts!
            raise
        except: 
            (exctype, excvalue) = sys.exc_info()[:2] 
            
            
            sys.stderr.write("%s while processing step %s element on element %s in file %s: %s\n" % (exctype.__name__,action,etxpath2human(elementpath,output.nsmap),output.filehref.getpath(),unicode(excvalue)))
            traceback.print_exc()
            
            status="exception"
            
            if debugmode and sys.stdin.isatty() and sys.stderr.isatty():
                # automatically start the debugger from an exception in debug mode (if stdin and stderr are ttys) 
                import pdb # Note: Should we consider downloading/installing ipdb (ipython support for pdb)???
                # run debugger in post-mortem mode. 
                pdb.post_mortem()
                pass


            pass

        stdouthandler.set_dest(None)
        stderrhandler.set_dest(None)

        output.should_be_rwlocked_once()

        rootprocess_el=output.restorepath(rootprocesspath)
        # Create lip:process element that contains lip:used tags listing all referenced elements
        element=output.restorepath(elementpath)
        # print "Reference location=%s" % (canonicalize_path.create_canonical_etxpath(output.filename,output.doc,rootprocess_el.getparent()))
        # print "Target location=%s" % (canonicalize_path.create_canonical_etxpath(output.filename,output.doc,element))
        # print "Relative location=%s" % (canonicalize_path.relative_etxpath_to(canonicalize_path.create_canonical_etxpath(output.filename,output.doc,rootprocess_el.getparent()),canonicalize_path.create_canonical_etxpath(output.filename,output.doc,element)))


        process_el=provenance.writeprocessprovenance(output,rootprocesspath,stepprocesspath,referenced_elements)
        
        # !!!*** should add dcp:used tag referencing step definition with 
        # prx file via sha256 hash of i18n canonicalization

        # write timestamps
        provenance.write_timestamp(output,process_el,"lip:starttimestamp",el_starttime)
        provenance.write_timestamp(output,process_el,"lip:finishtimestamp")
        provenance.write_process_info(output,process_el)  # We always write process info to ensure uniqueness of our UUID. It would be better to merge with parent elements before calculating UUID.

        captvalue = errcapt.getvalue()
        
        if bytes is str and isinstance(captvalue,str):
            # In python 2.x captvalue can end up as a str
            # not a unicode. 
            # But we should be writing unicode to the process log
            # ... so we need to decode the utf-8
            captvalue=captvalue.decode('utf-8')
            pass
        

        provenance.write_process_log(output,process_el,status,captvalue)

        provenance.write_target(output,process_el,dcv.hrefvalue.fromelement(output,element).value())  # lip:target -- target of this particular iteration (ETXPath)
        
        # Generate uuid
        process_uuid=provenance.set_hash(output,rootprocess_el,process_el)
    
        # Mark all modified elements with our uuid
        provenance.mark_modified_elements(output,modified_elements,process_uuid)

        errcapt.close()
        del errcapt

        output.should_be_rwlocked_once() 

        pass
    
    if matchcnt==0:
        sys.stderr.write("Warning: step %s: no matching elements for output href %s\n" % (processtrak_prxdoc.getstepname(prxdoc,steptag),output.get_filehref().absurl()))
        pass
    

    pass

def procsteppython(scripthref,pycode_el,prxdoc,output,steptag,scripttag,rootprocesspath,initelementmatch,initelementmatch_nsmap,elementmatch,elementmatch_nsmap,uniquematchel,params,filters,inputfilehref,debugmode,stdouthandler,stderrhandler,ipythonmodelist):
    # *** output should be rwlock'd exactly ONCE when this is called
    # *** Output will be rwlock'd exactly ONCE on return
    #     (but may have been unlocked in the interim)

    prxnsmap=dict(prxdoc.getroot().nsmap)

    stepglobals={}

    # !!!*** NON-REENTRANT
    # Temporarily adjust sys.path so as to add script's directory 
    
    syspath_save=sys.path
    syspath_new=copy.deepcopy(syspath_save)
    syspath_new.insert(0,os.path.split(scripthref.getpath())[0])
    sys.path=syspath_new

    if pycode_el is None: 
        #execfile(scripthref.getpath(),stepglobals)  # load in step
        
        with open(scripthref.getpath()) as f:
            code = compile(f.read(), scripthref.getpath(), 'exec')
            exec(code, stepglobals)
            pass
        
        pycode_text=None
        pycode_lineno=None
        pass
    else: 
        pycode_text=pycode_el.text
        pycode_lineno=pycode_el.sourceline
        # precede code with pycode_lineno blank lines so that parse errors, etc. get the right line number
        #pycode_parsed=ast.parse(("\n"*(pycode_lineno-1))+pycode_text,scriptpath)
        pycode_compiled=compile(("\n"*(pycode_lineno-1))+pycode_text,scripthref.getpath(),"exec")
        exec(pycode_compiled,stepglobals)
        pass
    sys.path=syspath_save
    
    # Find modules imported or referenced
    modules=set()
    for variable in stepglobals:
        if hasattr(variable,"__module__"):
            modulename=variable.__module__
            pass
        elif hasattr(variable,"__package__"):
            modulename=variable.__package__
            pass
        else: 
            continue
        modulenamesplit=modulename.split(".")
        for modulenamecomponentcnt in range(1,len(modulenamesplit)):
            trymodulename=".".join(modulenamesplit[:modulenamecomponentcnt])
            modules.add(trymodulename)
            pass
        pass
    # *** should Save module.__version__ and other version parameters with provenance!!!

    # create <lip:process> tag for this step 
    
    # output lock should be locked exactly once by caller
    output.should_be_rwlocked_once()
    #output.lock_rw()  # secure output lock

    rootprocess_el=output.restorepath(rootprocesspath)



    stepprocess_el=output.addelement(rootprocess_el,"lip:process")
    provenance.write_timestamp(output,stepprocess_el,"lip:starttimestamp")
    
    action=processtrak_prxdoc.getstepname(prxdoc,steptag)
    provenance.write_action(output,stepprocess_el,action)
    for module in (set(sys.modules.keys()) & modules):  # go through modules
        provenance.reference_pymodule(output,stepprocess_el,"lip:used",rootprocess_el.getparent(),module,warnlevel="none")
        pass

    provenance.write_process_info(output,stepprocess_el) # ensure uniqueness prior to uuid generation

    # Generate uuid
    stepprocess_uuid=provenance.set_hash(output,rootprocess_el,stepprocess_el)
    stepprocesspath=output.savepath(stepprocess_el)


    argkw={}

    initfunc=None
    
    # find "init" function or method
    if prxdoc.hasattr(steptag,"initfunction"):
        initfunc=stepglobals[prxdoc.getattr(steptag,"initfunction")]
        pass
    elif "initunlocked" in stepglobals:
        initfunc=stepglobals["initunlocked"]
        pass
    elif "init" in stepglobals : 
        initfunc=stepglobals["init"]
        pass

    if initfunc is not None:
        procsteppython_execfunc(scripthref,pycode_text,pycode_lineno,prxdoc,prxnsmap,output,steptag,scripttag,rootprocesspath,stepprocesspath,stepglobals,initelementmatch,initelementmatch_nsmap,params,[],inputfilehref,debugmode,stdouthandler,stderrhandler,ipythonmodelist,initfunc,action)
        pass
    
    
    # find "run" function or method
    if prxdoc.hasattr(steptag,"function"):
        runfunc=stepglobals[prxdoc.getattr(steptag,"function")]
        pass
    elif "rununlocked" in stepglobals:
        runfunc=stepglobals["rununlocked"]
        pass
    else : 
        runfunc=stepglobals["run"]
        pass


    procsteppython_execfunc(scripthref,pycode_text,pycode_lineno,prxdoc,prxnsmap,output,steptag,scripttag,rootprocesspath,stepprocesspath,stepglobals,elementmatch,elementmatch_nsmap,uniquematchel,params,filters,inputfilehref,debugmode,stdouthandler,stderrhandler,ipythonmodelist,runfunc,action)

    print("") # add newline

    # output.lock_rw()
    stepprocess_el=output.restorepath(stepprocesspath)
    provenance.write_timestamp(output,stepprocess_el,"lip:finishtimestamp")
    # output.unlock_rw()
    

    pass



def procstep(prxdoc,out,steptag,filters,overall_starttime,debugmode,stdouthandler,stderrhandler,ipythonmodelist):
    # *** output should be unlocked when this is called

    defaultelementmatch="*" # defaults to all child elements of main tag
    defaultelementmatch_nsmap=None
    try: 
        defaultelementmatchel=prxdoc.xpathsingle("prx:elementmatch")
        defaultelementmatch=defaultelementmatchel.text
        defaultelementmatch_nsmap=defaultelementmatchel.nsmap
        pass
    except NameError:
        pass

    scripttag=prxdoc.xpathsinglecontext(steptag,"prx:script")
    
 
    inputfilematch=["*"] # defaults to matching anything

    for inputfilematchel in prxdoc.xpath("prx:inputfilematch") + prxdoc.xpathcontext(steptag,"prx:inputfilematch") + prxdoc.xpathcontext(scripttag,"prx:inputfilematch"):
        if prxdoc.getattr(inputfilematchel,"mode",default="replace")=="union":
            # union
            inputfilematch.append(prxdoc.gettext(inputfilematchel))
            pass
        else:
            # replace
            inputfilematch=[ prxdoc.gettext(inputfilematchel) ]
            pass
        pass
    
    
    elementmatch=defaultelementmatch
    elementmatch_nsmap=defaultelementmatch_nsmap
    # sys.stderr.write("defaultelementmatch=%s\n" % (elementmatch))


    # try for <prx:elementmatch> in <step> 
    try: 
        elementmatchel=prxdoc.xpathsinglecontext(steptag,"prx:elementmatch")
        elementmatch=elementmatchel.text
        # sys.stderr.write("overrideelementmatch=%s\n" % (elementmatch))
        elementmatch_nsmap=elementmatchel.nsmap
        pass
    except NameError:
        pass

    uniquematchel=None
    try:
        uniquematchel=prxdoc.xpathsinglecontext(steptag,"prx:uniquematch")
        pass
    except NameError:
        pass


    ## try for <prx:inputfilematch> in <step> 
    #try: 
    #    inputfilematchel=prxdoc.xpathsinglecontext(steptag,"prx:inputfilematch")
    #inputfilematch=inputfilematchel.text
    #    # sys.stderr.write("overrideinputfilematch=%s\n" % (inputfilematch))
    #    pass
    #except NameError:
    #    pass

    
    # try for <prx:elementmatch> in <script> 
    try: 
        elementmatchel=prxdoc.xpathsinglecontext(scripttag,"prx:elementmatch")
        elementmatch=elementmatchel.text
        # sys.stderr.write("overrideelementmatch=%s\n" % (elementmatch))
        elementmatch_nsmap=elementmatchel.nsmap
        pass
    except NameError:
        pass

    try:
        uniquematchel=prxdoc.xpathsinglecontext(scripttag,"prx:uniquematch")
        pass
    except NameError:
        pass

    if uniquematchel is not None and elementmatch is not defaultelementmatch: 
        raise ValueError("Both prx:uniquematch and prx:element match specified for step %s" % (processtrak_prxdoc.getstepname(prxdoc,steptag)))
    
    
    
    ## try for <prx:inputfilematch> in <script> 
    #try: 
    #    inputfilematchel=prxdoc.xpathsinglecontext(scripttag,"prx:inputfilematch")
    #    inputfilematch=inputfilematchel.text
    #    # sys.stderr.write("overrideinputfilematch=%s\n" % (inputfilematch))
    #    pass
    #except NameError:
    #    pass


    # return if we don't pass filename matching
    
    if not any([ fnmatch.fnmatch(out.inputfilehref.get_bare_unquoted_filename(),inputfilematchstr) for inputfilematchstr in inputfilematch]):
        return
    

    print("\nProcessing step %s on %s->%s" % (processtrak_prxdoc.getstepname(prxdoc,steptag),out.inputfilehref.humanurl(),out.outputfilehref.humanurl()))

    
    
    initelementmatch="/*" # select root element
    initelementmatch_nsmap={}

    try: 
        initelementmatchel=prxdoc.xpathsinglecontext(scripttag,"prx:initelementmatch")
        initelementmatch=initelementmatchel.text
        initelementmatch_nsmap=initelementmatchel.nsmap
        pass
    except NameError:
        pass

                         
    pycode_el=None
    if prxdoc.hasattr(scripttag,"xlink:href"): 
        #scriptpath=prxdoc.get_href_fullpath(contextnode=scripttag)
        scripthref=dcv.hrefvalue.fromxml(prxdoc,scripttag)
        #scriptpath=scripthref.getpath()
        pass
    elif prxdoc.hasattr(scripttag,"name"): 
        scripthref=find_script_in_path(prxdoc.filehref,prxdoc.getattr(scripttag,"name"))
        pass
    else: 
        pycode_el=prxdoc.child(scripttag,"prx:pycode") # set to pycode tag or None
        scripthref=prxdoc.filehref
        if pycode_el is None: 
            raise ValueError("script %s does not specify file or python code" % (prxdoc.tostring(scripttag)))
        pass

    # Build parameter: dictionary by name of lists of stepparam objects
    params={}
    

    for paramel in prxdoc.xpathcontext(steptag,"prx:param|prx:script/prx:param"):
        paramname=prxdoc.getattr(paramel,"name")
        param=processtrak_stepparam.stepparam(name=paramname,prxdoc=prxdoc,element=paramel)

        if not param.name in params:
            params[param.name]=[]
            pass
        params[param.name].append(param)
        
        pass

    processtrak_common.open_or_lock_output(prxdoc,out,overall_starttime,copyfileinfo=None) # procsteppython/procstepmatlab are called with output locked exactly once
    try : 
        if pycode_el is not None or scripthref.get_bare_unquoted_filename().endswith(".py"):
            procsteppython(scripthref,pycode_el,prxdoc,out.output,steptag,scripttag,out.processpath,initelementmatch,initelementmatch_nsmap,elementmatch,elementmatch_nsmap,uniquematchel,params,filters,out.inputfilehref,debugmode,stdouthandler,stderrhandler,ipythonmodelist)
            pass
        elif scripthref.get_bare_unquoted_filename().endswith(".m"):
            procstepmatlab(scripthref.getpath(),prxdoc,out.output,steptag,scripttag,out.processpath,elementmatch,elementmatch_nsmap,uniquematchel,params,filters,out.inputfilehref,debugmode,ipythonmodelist)
            pass
        pass
    except: 
        raise
    finally: 
        out.output.unlock_rw() # procsteppython/procstepmatlab are called with output locked exactly once
        pass

    pass
