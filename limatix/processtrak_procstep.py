from __future__ import print_function

import sys
import os
import os.path
import posixpath
import socket
import shutil
import copy
import collections
import inspect
import numbers
import traceback
import collections
import tempfile
import re
import ast
import hashlib
import fnmatch
import binascii
from distutils.version import LooseVersion

from lxml import etree

# For some reason the fortran mkl librarys install their own 
# CTRL-C exit handler so the keyboard interupt exception 
# can never be caught. Setting the following environment variable 
# will disable the mkl CTRL-C installed handler.
# Set the environment variable FOR_DISABLE_CONSOLE_CTRL_HANDLER = '1'

try:
    from cStringIO import StringIO
    pass
except ImportError:
    from io import StringIO
    pass

from io import BytesIO

import shutil
import datetime
import subprocess

try:
    # py2.x
    from urllib import pathname2url
    from urllib import url2pathname
    from urllib import quote
    from urllib import unquote
    from urlparse import urlparse
    from urlparse import urlunparse
    from urlparse import urljoin    
    pass
except ImportError:
    # py3.x
    from urllib.request import pathname2url
    from urllib.request import url2pathname
    from urllib.parse import quote
    from urllib.parse import unquote
    from urllib.parse import urlparse
    from urllib.parse import urlunparse
    from urllib.parse import urljoin
    pass


try: 
    import builtins  # python3
    pass
except ImportError: 
    import __builtin__ as builtins # python2
    pass

if not hasattr(builtins,"unicode"):
    # python3
    unicode=str
    pass

if not hasattr(builtins,"basestring"):
    # python3
    basestring=str
    pass

if not hasattr(builtins,"long"):
    # python3
    long=int
    pass

if not hasattr(builtins,"ModuleNotFoundError"):
    # python2
    ModuleNotFoundError=ImportError
    pass



# import dg_units

from . import timestamp
from . import canonicalize_path
from .canonicalize_path import etxpath2human

from . import dc_value as dcv
from . import provenance as provenance
from . import xmldoc
from . import processtrak_prxdoc
from . import processtrak_stepparam
from . import processtrak_common


try:
    from pkg_resources import resource_string
    from pkg_resources import iter_entry_points
    pass
except TypeError:
    # mask lack of pkg_resources when we are running under pychecker
    def resource_string(x,y):
        raise IOError("Could not import pkg_resources")
    pass


try: 
    __install_prefix__=resource_string(__name__, 'install_prefix.txt').decode('utf-8')
    pass
except IOError: 
    sys.stderr.write("processtrak: error reading install_prefix.txt. Assuming /usr/local.\n")
    __install_prefix__="/usr/local"
    pass


def check_importability(py_module_name):
    try:
        import pkgutil
        return pkgutil.find_loader(py_module_name) is not None
    except ModuleNotFoundError:
        return False
    return False
# getstepurlpath now in __init__.py
#def getstepurlpath():
#    return [ pathname2url(os.path.join(__install_prefix__,"share","limatix","pt_steps")) ]

def get_stephrefpaths(primary=False):
    # obtain step path by merging lists generated by limatix.datacollect2.stepurlpath entrypoints.
    # primary=True limits it to just the main /usr/share/limatix/pt_steps or similar
    
    steppath = []

    module_version_map = {}
    for entrypoint in iter_entry_points("limatix.processtrak.step_url_search_path"):
        steppathfunc=entrypoint.load()

        module_version = (None, None)
        # See if we can get module version data for provenance tracking
        if hasattr(steppathfunc,"__module__") and steppathfunc.__module__ in sys.modules:
            module=sys.modules[steppathfunc.__module__]
            module_version = (module,None)
            if hasattr(module,"__version__"):
                # Got valid version string
                module_version = (module,module.__version__)
                pass
            pass
        
        
        add_to_steppath = steppathfunc()
        if isinstance(add_to_steppath,basestring):
            sys.stderr.write("limatix.processtrak_procstep: Error enumerating limatix.datacollect2.ptstepurlpath entry points: Got string from %s:%s; expected list or tuple\n" % (entrypoint.module_name,entrypoint.name))
            continue

        # build database indexed by search path of source module & version
        for pathentry in add_to_steppath:
            module_version_map[pathentry] = module_version
            pass
        
        if not primary or entrypoint.name=="limatix.share.pt_steps":            
            steppath.extend(add_to_steppath)
            pass
        pass

    stephrefpaths=[ dcv.hrefvalue(stepurl) if stepurl.endswith(posixpath.sep) else dcv.hrefvalue(stepurl+posixpath.sep) for stepurl in steppath ]
    module_versions = [ module_version_map[pathentry] for pathentry in steppath ] 
    return (stephrefpaths,module_versions)
    


def find_script_in_path(contexthref,scriptname):
    #if os.path.exists(os.path.join(contexthref.getpath(),scriptname)):
    #    print("WARNING: direct paths to scripts should be specified with <script xlink:href=\"...\"/>. Use the name=\"...\" attribute only for scripts to be found in the script search path")
    #    pass
    
    #if posixpath.isabs(scriptname):
    #    return dcv.hrefvalue(quote(scriptname),contexthref=dcv.hrefvalue("./"))
    #
    #if posixpath.pathsep in scriptname:
    #    return dcv.hrefvalue(quote(scriptname),contexthref=contexthref)

    (stephrefpaths,module_versions) = get_stephrefpaths()

    for hrefpathindex in range(len(stephrefpaths)):
        tryhrefpath = stephrefpaths[hrefpathindex]
        module_version = module_versions[hrefpathindex]

        candidate=dcv.hrefvalue(quote(scriptname),contexthref=tryhrefpath)
        if os.path.exists(candidate.getpath()):
            return (candidate,module_version)
        pass
    
    raise IOError("Could not find script %s in path %s" % (scriptname,unicode([ searchhref.humanurl() for searchhref in stephrefpaths ])))


def escapematlab(to_escape,comsol=False):
    """Escape special characters that can't go verbatim into a MATLAB quoted string passed to sprintf. 
    in COMSOL mode we hex-escape the entire string because in passing MATLAB commands through COMSOL spaces get 
    converted to semicolons (?) and this is problematic."""
    ret=[]

    ind = 0

    if not comsol:
        while ind < len(to_escape):
            if to_escape[ind]=='\'':
                ret.append('\'\'')
                pass
            elif to_escape[ind]=='\n':
                ret.append('\'\'')
                ret.append('n')
                pass
            elif to_escape[ind]=='\r':
                ret.append('\'\'')
                ret.append('r')
                pass
            elif to_escape[ind]=='%':
                ret.append('%%')
                pass
            elif to_escape[ind]=='\\':
                ret.append('\\\\')
                pass
            else:
                ret.append(to_escape[ind])
                pass
            ind += 1
            pass
        pass
    else:
        # comsol
        while ind < len(to_escape):
            if to_escape[ind]=='%': # Even when passed as hex, percent signs still need escaped... but they are safe to print verbatim
                ret.append("%%")
                pass
            else:
                ret.append("\\x%x" % (ord(to_escape[ind])))
                pass
            ind += 1
            pass
        
        pass
    return "".join(ret)


def matlab_retval_to_resulttuple(retval):
    # retval from varible "ret" extracted from return from scipy.io.loadmat()
    resultlist=[]

    # Iterate over root cell array
    import numpy as np

    for el in retval.ravel():
        assert(el.dtype == np.dtype('O'))
        # Object... it is a sub-cell array
        # First element of el should be either fieldname, or (fieldname,attribute dictionary) cell array
        # Second element of el should be field value
        assert(el.shape==(1,2))
        fieldinfo = el[0,0]
        fieldvalue = el[0,1]

        # Is fieldinfo directly a string (Unicode)?
        
        if fieldinfo.dtype.char=='U':
            python_fieldname = fieldinfo[0]

            python_fieldinfo = python_fieldname
            pass
        else:
            # fieldinfo is a cell array (fieldname, attribute dictionary)
            assert(fieldinfo.dtype == np.dtype('O'))

            
            # Extract fieldname
            assert(fieldinfo.shape==(1,2))
            assert(fieldinfo[0,0].dtype.char=='U')
            python_fieldname = fieldinfo[0,0][0]

            # Extract attribute dictionary... should be an (n x 2) cell array where each row is a key value pair
            fielddict = fieldinfo[0,1]
            assert(fielddict.dtype == np.dtype('O'))

            python_fielddict={}
            
            nrows = fielddict.shape[0]
            assert(len(fielddict.shape)==2 and fielddict.shape[1]==2)

            for rowcnt in range(nrows):
                key = fielddict[rowcnt,0]
                value = fielddict[rowcnt,1]

                # key should be a string; value should be unicode or a float or integer of some type
                assert(key.dtype.char=='U')
                python_key = unicode(key[0])

                if value.dtype.char=='U':
                    # string/unicode value
                    python_value = unicode(value[0])
                    pass
                else:
                    # assume numeric -- stored as 2D array
                    assert(value.shape==(1,1))
                    numeric_value = value[0,0]

                    # cast integral values to int, others to float or complex
                    if np.imag(numeric_value)==0.0 and int(numeric_value)==numeric_value:
                        python_value = int(numeric_value)
                        pass
                    elif np.imag(numeric_value)==0.0:
                        python_value = float(numeric_value)
                        pass
                    else:
                        python_value = complex(numeric_value)
                        pass
                    pass

                # python_key and python_value are set for this row
                python_fielddict[python_key] = python_value
                
                pass
            python_fieldinfo = (python_fieldname,python_fielddict)
            pass
        
        # Ok. Got fieldinfo. Now get fieldvalue
        if fieldvalue.dtype.char=='U':
            # string/unicode value
            python_fieldvalue = unicode(fieldvalue[0])
            pass
        elif fieldvalue.dtype == np.dtype('O'):
            # nested cell array -- interpret as an hrefvalue with a path
            assert(fieldvalue.shape==(1,1))
            assert(fieldvalue[0,0].dtype.char=='U')
            hrefpath = fieldvalue[0,0][0]
            hrefurl = pathname2url(hrefpath)
            python_fieldvalue = dcv.hrefvalue(hrefurl,contexthref=dcv.hrefvalue("./"))            
            
            pass
        else:
            
            # assume numeric -- stored as 2D array
            assert(fieldvalue.shape==(1,1))
            numeric_fieldvalue = fieldvalue[0,0]

            # cast integral values to int, others to float
            if np.imag(numeric_fieldvalue)==0.0 and int(numeric_fieldvalue)==numeric_fieldvalue:
                python_fieldvalue = int(numeric_fieldvalue)
                pass
            elif np.imag(numeric_fieldvalue)==0.0:
                python_value = float(numeric_fieldvalue)
                pass
            else:
                python_fieldvalue = complex(numeric_fieldvalue)
                pass
            pass
        
        resultlist.append((python_fieldinfo,python_fieldvalue))
        
        pass
    
    return tuple(resultlist)


def procstepmatlab_do_run(matlabcode_el_text,matpath,scriptname,diaryfilename,retfilename,argkw,ipythonmodelist,action,scripthref,status,comsol=False):
    
    # Need to generate MATLAB initialization string from argkw and ipythonmodelist
    # ... MATLAB takes a sequence of commands to run.
    # Need the parameter assignments, script name, 
    matlabinitstrings = []

    matlabinitstrings.append("processtrak=true;retcommand=sprintf(\'%s\');" % (escapematlab("save(\'%s\',\'ret\',\'-v7\');quit;" % (retfilename),comsol=comsol)))
    
    matlabinitstrings.append("fprintf(1,\'%s\');" % (escapematlab("To store output and exit enter: eval(retcommand)\n",comsol=comsol)))

    # Add diary call to record output
    matlabinitstrings.append("diary(\'%s\');" % (diaryfilename))

    # Add parameter assignments
    for argname in argkw:
        argvalue = argkw[argname]

        if isinstance(argvalue,basestring):
            # a string!
            matlabinitstrings.append("%s=sprintf(\'%s\');" % (argname,escapematlab(argvalue,comsol=comsol)))
            pass
        elif isinstance(argvalue,int) or isinstance(argvalue,long): # Python 3 no longer distinguishes long and int
            # an integer!
            matlabinitstrings.append("%s=%d;" % (argname,argvalue))
            pass
        elif isinstance(argvalue,float):
            # floating point number
            matlabinitstrings.append("%s=%.32e;" % (argname,argvalue))
            pass
        elif isinstance(argvalue,dcv.hrefvalue):
            # hypertext reference -- passed as string path wrapped by a cell array
            matlabinitstrings.append("%s={sprintf(\'%s\')};" % (argname,escapematlab(argvalue.getpath(),comsol=comsol)))
            pass
        else:
            raise ValueError("Parameter %s is of type %s which cannot be passed to MATLAB." % (argname,type(argvalue).__name__))
        pass

    # COMSOL has MATLAB do a chdir()... we need to undo that
    if comsol:
        matlabinitstrings.append("cd(sprintf(\'%s\'));" % (escapematlab(os.getcwd(),comsol=comsol)))
        pass


    if matlabcode_el_text is None:
        # add call to script
        matlabinitstrings.append("%s;" % (os.path.splitext(scriptname)[0]))
        pass
    else:
        # add matlab code as sprintf string, then eval() it.
        #sys.stderr.write('matlabcode_el_text=\"%s\"\n' % (matlabcode_el_text))
        matlabinitstrings.append("matlabcode_text=sprintf(\'%s\');" % (escapematlab(matlabcode_el_text,comsol=comsol)))

        matlabinitstrings.append("eval(matlabcode_text);")
        
        pass
    # add save of 'ret' variable and exit on completion
    if not ipythonmodelist[0]:
        # Not ipythonmode -- auto save and quit
        matlabinitstrings.append("save(\'%s\',\'ret\',\'-v7\');quit;" % (retfilename))
        pass
    else:
        matlabinitstrings.append("fprintf(1,\'%s\');" % (escapematlab("You can connect to the comsol server with comsol client if you would like.\nStore output and exit when done with: eval(retcommand)\n",comsol=comsol)))        
        pass
    

    matlabinitstring = "".join(matlabinitstrings)

    # Run MATLAB
    matlabenv=copy.copy(os.environ)
    matlabenv["MATLABPATH"]=matpath

    if comsol:

        if os.name=='nt': # on Windows it's "comsolmphserver" not "comsol mphserver"
            execlist = ["comsolmphserver","matlab",matlabinitstring,"-graphics"]
            pass
        else:
            execlist = ["comsol","mphserver","matlab",matlabinitstring,"-graphics"]
            pass
        
        pass
    else:
        execlist = ["matlab","-r",matlabinitstring]
        pass
    
    matproc = subprocess.Popen(execlist,close_fds=True,env=matlabenv)
    rc=matproc.wait()

    diarytext=""

    if rc != 0:
        diarytext += "MATLAB execution failed. Command line=%s\n" % (" ".join(execlist))
        pass

    retval = None
    
    # Attempt to read in diary and ret files
    if os.path.exists(diaryfilename):
        diaryfh = open(diaryfilename,"r")
        diarytext += diaryfh.read()
        diaryfh.close()

        if unicode is not str: 
            # python 2.7
            diarytext=diarytext.decode('utf8') # decode any special characters
            pass


        if os.path.exists(retfilename):
            import scipy.io
            retfile = scipy.io.loadmat(retfilename)
            retval = retfile["ret"]
            pass
        else:
            diarytext += "\nMATLAB script failed to assign and return ret\n"
            pass
        pass
    else:
        status="exception"
        diarytext+="MATLAB execution failed (no diary written). Command line=%s\n" % (" ".join(execlist))
        pass

    print(diarytext) # Display MATLAB output to console

    if retval is not None:
        # Interpret "ret" value as like a tuple-form resultdict represented with cell arrays
        # Note -- a string-in-cell-array value is interpreted as a path to be converted to a hrefvalue

        # Each MATLAB cell array manifests in retval (or an element of retval) as a 2D array of objects.
        # elements of that 2D array could be another 2D array representing a cell array, a (2D?) array
        # of float, or an array of unicode (strings)

        resultdict = matlab_retval_to_resulttuple(retval)
        
        pass
    else:
        resultdict={}
        pass

    return (resultdict,status,diarytext)

def procstepmatlab_runelement(matlabcode_el_text,matpath,scriptname,output,prxdoc,prxnsmap,steptag,rootprocesspath,stepprocesspath,elementpath,uniquematches,argnames,params,inputfilehref,ipythonmodelist,paramdebug,action,scripthref,diaryfilename,retfilename,status,comsol=False):
    # *** output should be rwlock'd exactly ONCE when this is called
    # *** Output will be rwlock'd exactly ONCE on return
    #     (but may have been unlocked in the interim)


    run_matlab_unlocked = True

    element=output.restorepath(elementpath)

    print("Element %s\r" % (dcv.hrefvalue.fromelement(output,element).humanurl()),end="\r")
    #print("Element %s\r" % (canonicalize_path.getelementhumanxpath(output,element,nsmap=prxnsmap)),end="\r")
    sys.stdout.flush()

    rootprocess_el=output.restorepath(rootprocesspath)
    
    provenance.starttrackprovenance()
    try : # try-catch-finally block for starttrackprovenance()
        
        argkw = procstep_evalargs(output,prxdoc,prxnsmap,steptag,uniquematches,argnames,{},params,inputfilehref,element,paramdebug)    

        
        # unlock XML file if "run_matlab_unlocked" so parallel processes can mess with it
        if run_matlab_unlocked: 
            
            output.unlock_rw() # release output lock 
            try: 
                (resultdict,status,diarytext)=procstepmatlab_do_run(matlabcode_el_text,matpath,scriptname,diaryfilename,retfilename,argkw,ipythonmodelist,action,scripthref,status,comsol=comsol)
                pass
            finally: 
                output.lock_rw() # secure output lock ... otherwise
                # an exception would be handled several levels above
                # which assumes we are locked. 
                pass
            
            del rootprocess_el
            element=output.restorepath(elementpath)
            
            pass
        else: 
            (resultdict,status,diarytext)=procstepmatlab_do_run(matlabcode_el_text,matpath,scriptname,diaryfilename,retfilename,argkw,ipythonmodelist,action,scripthref,status,comsol=comsol)
            # print("processtrak: print_current_used() after do_run of %s" % (str(execfunc)))
            # provenance.print_current_used()
            
            
            output.should_be_rwlocked_once() # Verify that after running, the output is still locked exactly once
            element=output.restorepath(elementpath) # run function may have unlocked output temporarily so we need to restore the element from its path
            pass
        
        if resultdict is None: 
            resultdict={}  # no results provided
            pass
        
        
        applyresultdict(output,prxdoc,steptag,element,resultdict)
    
        pass
    except:
        raise
    finally:
        # print("processtrak: print_current_used()")
        # provenance.print_current_used()

        (modified_elements,referenced_elements)=provenance.finishtrackprovenance()
        pass

    # exit with output still in locked state. 
    return (modified_elements,referenced_elements,status,diarytext)



def procstepmatlab_execfunc(scripthref,matlabcode_el_text,script_firstline,matpath,scriptname,prxdoc,prxnsmap,output,steptag,scripttag,rootprocesspath,stepprocesspath,elementmatch,elementmatch_nsmap,uniquematchel,params,filters,inputfilehref,debugmode,ipythonmodelist,paramdebug,action,comsol=False):

    # Parse script_firstline
    # First line of matlab script is expected to be:
    #   function ret = SCRIPTNAME(dc_param1_str, dc_param2_int, dc_param3_float, dc_param4_href)
    firstlinegroups=re.match(r"""\s*%\s*function\s*(\[\s*)?ret\s*(]\s*)?=\s*\w+[(]\s*((\w+\s*,\s*)*)(\w+\s*)?[)]\s*""",script_firstline)

    if firstlinegroups is None:
        raise ValueError("Error parsing first line of MATLAB script %s: %s expected format: \"function ret = SCRIPTNAME(dc_param1_str, dc_param2_int, dc_param3_float, dc_param4_href)\"" % (scripthref.humanurl(),script_firstline))
    
    trailing_comma_params = firstlinegroups.group(3)
    final_param = firstlinegroups.group(5)  # May be None if no params provided

    # Iterate over trailing_comma_params to get individual parameters
    trailing_comma_param_list = re.findall(r"""(\w+)\s*,\s*""",trailing_comma_params)

    argnames = trailing_comma_param_list + [ final_param.strip() ] # List of all parameters
    

    if uniquematchel is not None:
        procstep_elementpath_generator = procstep_uniquematch_elementpath_generator
        pass
    else:
        procstep_elementpath_generator = procstep_elementmatch_elementpath_generator
        pass
    

    # output.unlock_rw() # release output lock

    matchcnt=0

    # Loop over each matching element
    for (elementpath,uniquematches) in procstep_elementpath_generator(prxdoc,output,steptag,elementmatch,elementmatch_nsmap,uniquematchel,filters):
        # elementpath is the path to the element we have found that we are
        # supposed to be operating on
        # uniquematches, if it is not None, and for is a list of elements
        # that matched the key of the <prx:uniquematch> element
        # giving rise to this element. 

        
        matchcnt+=1
        modified_elements=set([])
        referenced_elements=set([])

        el_starttime=timestamp.now().isoformat()


        # "Diary" directory/file for capturing MATLAB output
        tmpoutputdir=tempfile.mkdtemp(prefix="pt_matlab_output")
        diaryfilename=os.path.join(tmpoutputdir,"diary.txt")
        retfilename=os.path.join(tmpoutputdir,"ret.txt")
        
        
        status="success"

        output.should_be_rwlocked_once()

        try : 
            (modified_elements,referenced_elements,status,diarytext)=procstepmatlab_runelement(matlabcode_el_text,matpath,scriptname,output,prxdoc,prxnsmap,steptag,rootprocesspath,stepprocesspath,elementpath,uniquematches,argnames,params,inputfilehref,ipythonmodelist,paramdebug,action,scripthref,diaryfilename,retfilename,status,comsol=comsol)
            pass
        except KeyboardInterrupt: 
            # Don't want to hold off keyboard interrupts!
            # sync output... Should be a better way to do this, since it is locked
            output.unlock_rw()
            output.lock_rw()
            raise
        except: 
            (exctype, excvalue) = sys.exc_info()[:2] 
            
            
            diarytext="%s while processing step %s element on element %s in file %s: %s\n" % (exctype.__name__,action,etxpath2human(elementpath,output.nsmap),output.filehref.getpath(),unicode(excvalue))
            sys.stderr.write(diarytext)
            traceback.print_exc()
            
            status="exception"

            # sync output... Should be a better way to do this, since it is locked
            output.unlock_rw()
            output.lock_rw()

            if debugmode and sys.stdin.isatty() and sys.stderr.isatty():
                # automatically start the debugger from an exception in debug mode (if stdin and stderr are ttys) 
                import pdb # Note: Should we consider downloading/installing ipdb (ipython support for pdb)???
                # run debugger in post-mortem mode. 
                pdb.post_mortem()
                pass


            pass

        
        # delete tmpoutputdir
        #shutil.rmtree(tmpoutputdir)

        output.should_be_rwlocked_once()
        
        rootprocess_el=output.restorepath(rootprocesspath)
        # Create lip:process element that contains lip:used tags listing all referenced elements
        element=output.restorepath(elementpath)
        # print "Reference location=%s" % (canonicalize_path.create_canonical_etxpath(output.filename,output.doc,rootprocess_el.getparent()))
        # print "Target location=%s" % (canonicalize_path.create_canonical_etxpath(output.filename,output.doc,element))
        # print "Relative location=%s" % (canonicalize_path.relative_etxpath_to(canonicalize_path.create_canonical_etxpath(output.filename,output.doc,rootprocess_el.getparent()),canonicalize_path.create_canonical_etxpath(output.filename,output.doc,element)))


        process_el=provenance.writeprocessprovenance(output,rootprocesspath,stepprocesspath,referenced_elements)
        
        # !!!*** should add dcp:used tag referencing step definition with 
        # prx file via sha256 hash of i18n canonicalization

        # write timestamps
        provenance.write_timestamp(output,process_el,"lip:starttimestamp",el_starttime)
        provenance.write_timestamp(output,process_el,"lip:finishtimestamp")
        provenance.write_process_info(output,process_el)  # We always write process info to ensure uniqueness of our UUID. It would be better to merge with parent elements before calculating UUID.
        
        
        # For some reason, diary text has weird control characters 
        # especially ctrl-h (\x08)... which are incompatible with xml.
        # Strip these
        diarytext_stripped = diarytext.replace("\x08","")

        provenance.write_process_log(output,process_el,status,diarytext_stripped)

        target_el=provenance.write_target(output,process_el,dcv.hrefvalue.fromelement(output,element).value())  # lip:target -- target of this particular iteration (ETXPath)

        #if target_el.attrib["{http://www.w3.org/1999/xlink}href"].startswith(".#"):
        #    import pdb
        #    pdb.set_trace()
        #
        #target_hrefc = dcv.hrefvalue.fromelement(output,element).value()
        #    target_context = output.getcontexthref().value()
        #    target_hrefc.attempt_relative_url(target_context)
        #    pass
        
        # Generate uuid
        process_uuid=provenance.set_hash(output,rootprocess_el,process_el)
    
        # Mark all modified elements with our uuid
        provenance.mark_modified_elements(output,modified_elements,process_uuid)


        output.should_be_rwlocked_once() 

        pass
    
    if matchcnt==0:
        sys.stderr.write("Warning: step %s: no matching elements for output href %s\n" % (processtrak_prxdoc.getstepname(prxdoc,steptag),output.get_filehref().absurl()))
        pass
    

    pass


def procstepmatlab(scripthref,matlabcode_el,prxdoc,output,steptag,scripttag,rootprocesspath,elementmatch,elementmatch_nsmap,uniquematchel,params,filters,inputfilehref,debugmode,ipythonmodelist,paramdebug,comsol=False):

    # comsol parameter enables running Matlab through comsol server to run
    # COMSOL model creation scripts written in Matlab
    
    # *** output should be rwlock'd exactly ONCE when this is called
    # *** Output will be rwlock'd exactly ONCE on return
    #     (but may have been unlocked in the interim)


    scriptpath = scripthref.getpath()
    
    prxnsmap=dict(prxdoc.getroot().nsmap)


    # adjust MATLABPATH so as to add script's directory 

    scriptfullpath=os.path.abspath(scriptpath)
    (scriptfulldir,scriptname)=os.path.split(scriptfullpath)

    if "MATLABPATH" in os.environ:        
        matpath = "%s%s%s" % (scriptfulldir,os.pathsep,os.environ["MATLABPATH"])
        pass
    else:
        matpath=scriptfulldir
        pass

    if matlabcode_el is not None:
        # inline MATLAB code
        scripttext = matlabcode_el.text
        matlabcode_el_text = scripttext
        pass
    else:
        # Read MATLAB code from file to get header info
        scripttext_fh=open(scriptfullpath,"r")
        scripttext = scripttext_fh.read()
        scripttext_fh.close()
        
        matlabcode_el_text = None        
        pass
    
    scripttext_lines = scripttext.split("\n")
    # ignore leading blank lines
    lineidx=0
    while scripttext_lines[lineidx].isspace() and lineidx < len(scripttext_lines)-1:
        lineidx+=1
        pass
    
    script_firstline = scripttext_lines[lineidx]

    # First line of matlab script is expected to be:
    #   function ret = SCRIPTNAME(dc_param1_str, dc_param2_int, dc_param3_float, dc_param4_href)
    # href values are platform OS paths as a single element cell array. 
    

    # create <lip:process> tag for this step 
    
    # output lock should be locked exactly once by caller
    output.should_be_rwlocked_once()
    #output.lock_rw()  # secure output lock

    rootprocess_el=output.restorepath(rootprocesspath)


    stepprocess_el=output.addelement(rootprocess_el,"lip:process")
    provenance.write_timestamp(output,stepprocess_el,"lip:starttimestamp")
    
    action=processtrak_prxdoc.getstepname(prxdoc,steptag)
    provenance.write_action(output,stepprocess_el,action)
    
    
    provenance.reference_pt_script(output,stepprocess_el,"lip:used",rootprocess_el.getparent(),scripthref,(None,None))
    
    provenance.write_process_info(output,stepprocess_el) # ensure uniqueness prior to uuid generation

    # Generate uuid
    stepprocess_uuid=provenance.set_hash(output,rootprocess_el,stepprocess_el)
    stepprocesspath=output.savepath(stepprocess_el)


    argkw={}

    #initfunc=None
    #
    ## find "init" function or method
    #if prxdoc.hasattr(steptag,"initfunction"):
    #    initfunc=stepglobals[prxdoc.getattr(steptag,"initfunction")]
    #    pass
    #elif "initunlocked" in stepglobals:
    #    initfunc=stepglobals["initunlocked"]
    #    pass
    #elif "init" in stepglobals : 
    #    initfunc=stepglobals["init"]
    #    pass
    #
    #if initfunc is not None:
    #    procsteppython_execfunc(scripthref,pycode_text,pycode_lineno,prxdoc,prxnsmap,output,steptag,scripttag,rootprocesspath,stepprocesspath,stepglobals,initelementmatch,initelementmatch_nsmap,uniquematchel,params,[],inputfilehref,debugmode,stdouthandler,stderrhandler,ipythonmodelist,initfunc,action)
    #    pass
    
    
    procstepmatlab_execfunc(scripthref,matlabcode_el_text,script_firstline,matpath,scriptname,prxdoc,prxnsmap,output,steptag,scripttag,rootprocesspath,stepprocesspath,elementmatch,elementmatch_nsmap,uniquematchel,params,filters,inputfilehref,debugmode,ipythonmodelist,paramdebug,action,comsol=comsol)

    print("") # add newline

    # output.lock_rw()
    stepprocess_el=output.restorepath(stepprocesspath)
    provenance.write_timestamp(output,stepprocess_el,"lip:finishtimestamp")
    # output.unlock_rw()

    pass



def procsteppython_do_run(stepglobals,runfunc,argkw,ipythonmodelist,action,scripthref,pycode_text,pycode_lineno):

    if not ipythonmodelist[0]:
        stepglobals["__processtrak_interactive"] = False # interactive mode can be disabled but no reenabled, so if we get here it is False permanently and safe to set globally
        try: 
            resultdict=runfunc(**argkw)
            return resultdict
        finally:
            if 'matplotlib.pyplot' in sys.modules:
                from matplotlib import pyplot as plt
                plt.close('all')
                pass
            pass
    else:
        try: #matched with finally clause that closes matplotlib plots
            # ipython mode
            # in-process kernel, a-la https://raw.githubusercontent.com/ipython/ipython/master/examples/Embedding/inprocess_qtconsole.py

            ## Set PyQt4 API version to 2 and import it -- required for ipython compatibility
            #import sip
            #sip.setapi('QVariant', 2)
            #sip.setapi('QString', 2)
            #sip.setapi('QDateTime', 2)
            #sip.setapi('QDate', 2)
            #sip.setapi('QTextStream', 2)
            #sip.setapi('QTime', 2)
            #sip.setapi('QUrl', 2)
            #from PyQt4 import QtGui   # force IPython to use PyQt4 by importing it first

        
            # RHEL6 compatibility  -- if running under Python 2.6, just import IPython, get PyQt4
            if sys.version_info < (2,7):
                from IPython.qt.console.rich_ipython_widget import RichIPythonWidget
                from IPython.qt.inprocess import QtInProcessKernelManager
                import IPython
                from IPython.core.interactiveshell import DummyMod
            
                # (Old versions of IPython only)
                from IPython.qt.inprocess import QtInProcessKernelManager
                from IPython.lib import guisupport
                app = guisupport.get_app_qt4() 
                
                qt_version=4 # default to qt4
                using_pyside=False

                pass
            else: 
                
                # Under more recent OS's: Make matplotlib use PySide
                # http://stackoverflow.com/questions/6723527/getting-pyside-to-work-with-matplotlib
                import IPython
                from IPython.core.interactiveshell import DummyMod

                if LooseVersion(IPython.__version__) >= LooseVersion('4.0.0'):
                    # Recent Jupyter/ipython: Import from qtconsole
                    
                    # Just get what ever is already imported if present:
                    def figure_imported_qt():
                        qt_version=4 # default to qt4
                        using_pyside=False

                        if "PySide.QtCore" in sys.modules:
                            import PySide.QtCore
                            using_pyside=True
                            pass
                        elif "PySide2.QtCore" in sys.modules:
                            import PySide2.QtCore
                            qt_version=5
                            using_pyside=True
                            pass
                        elif "PyQt4.QtCore" in sys.modules:
                            import PyQt4.QtCore
                            pass
                        elif "PyQt5.QtCore" in sys.modules:
                            import PyQt5.QtCore
                            qt_version=5
                            pass
                        else:
                            qt_version=None
                            using_pyside=None
                            pass
                        return (qt_version,using_pyside)
                    (qt_version,using_pyside)=figure_imported_qt()
                    
                    if qt_version is None:
                        # Try new import
                        # Let matplotlib backend availability determine which version
                        if check_importability("matplotlib.backends.backend_qt5agg"):
                            if check_importability("PySide2") or check_importability("PyQt5"):
                                from matplotlib.backends import backend_qt5agg
                                pass
                            pass

                        if check_importability("matplotlib.backends.backend_qt4agg"):
                            if check_importability("PySide") or check_importability("PyQt4"):
                                from matplotlib.backends import backend_qt4agg
                                pass
                            pass

                        (qt_version,using_pyside)=figure_imported_qt()
                        
                        pass
                    pass
                else:
                    # prehistoric IPython version ( < 4.... assume qt4 with pyside)
                    qt_version=4
                    using_pyside=True
                    pass
                
                import matplotlib
                if qt_version==4:
                    #print("Using qt4")
                    matplotlib.use('Qt4Agg')
                    if 'backend.qt4' in matplotlib.rcParams.keys() and using_pyside:
                        matplotlib.rcParams['backend.qt4']='PySide'
                        pass
                    pass
                else:
                    #print("Using qt5")
                    matplotlib.use('Qt5Agg')
                    pass
            

                if LooseVersion(IPython.__version__) >= LooseVersion('4.0.0'):
                    # Recent Jupyter/ipython: Import from qtconsole            
                    try:
                        from qtconsole.qt import QtGui
                        QApplication = QtGui.QApplication
                    except ModuleNotFoundError:
                        # Recent qtconsole version does not contain qt module
                        if qt_version == 4:
                            from PyQt4 import QtGui, QtWidgets
                            QApplication = QtWidgets.QApplication
                        elif qt_version == 5:
                            from PyQt5 import QtGui, QtWidgets
                            QApplication = QtWidgets.QApplication
                        else:
                            raise ModuleNotFoundError("Cannot find valid PyQt installation.")
                        pass
                    from qtconsole.inprocess import QtInProcessKernelManager
                
                    # Obtain the running QApplication instance
                    app=QApplication.instance()
                    if app is None:
                        # Start our own if necessary
                        app=QApplication([])
                        pass
                
                    pass
                else:
                    # (Old versions of IPython only)
                    from IPython.qt.inprocess import QtInProcessKernelManager
                    from IPython.lib import guisupport
                    app = guisupport.get_app_qt4() 
                    pass
            
                pass
            
            if qt_version==4:
                kernel_gui = 'qt4'
                pass
            elif qt_version==5:
                kernel_gui = 'qt'
                pass
            else:
                assert(0) # invalid kernel_gui
                pass
        

            kernel_manager = QtInProcessKernelManager()
            kernel_manager.start_kernel()
            kernel = kernel_manager.kernel
            kernel.gui = kernel_gui
            
        
            if LooseVersion(IPython.__version__) >= LooseVersion('7.0.0'):
                kernel.start()

                import ipykernel
                if (not hasattr(kernel,"io_loop")) and (LooseVersion(ipykernel.__version__) < LooseVersion('6.4.2')):
                    # Some versions of ipykernel (e.g. 5.1.4 )
                    # the InProcessKernel start() method
                    # doesn't call its superclass to (apparently)
                    # override registration of dispatcher streams.
                    # but this means that the  the io_loop and
                    # msg_queue also don't get setup, which is problematic.
                    # In the streams are None/Empty so the stream ops
                    # are no-ops
                    # fixed in v6.4.2 by https://github.com/ipython/ipykernel/pull/781

                    #print("k.c_s = %s" % (str(kernel.control_stream)))
                    #print("len(k.s_s) = %d" % (len(kernel.shell_streams)))
                
                    import ipykernel.kernelbase
                    # Call the base class method directly 
                    ipykernel.kernelbase.Kernel.start(kernel)
                    pass
                ## Set IOLoop for kernel
                ## similar to example in https://psyplot.readthedocs.io/projects/psyplot-gui/en/latest/_modules/psyplot_gui/console.html
                #from zmq.eventloop import ioloop as zmq_ioloop
                #from tornado import ioloop as tdo_ioloop
                #zmq_ioloop.install()
                #kernel.io_loop = tdo_ioloop.IOLoop.current()
                pass
        
        
            #sys.stderr.write("id(stepglobals)=%d" % (id(stepglobals)))
            
            # Make ipython use our globals as its global dictionary
            # ... but first keep a backup
            stepglobalsbackup=copy.copy(stepglobals)
        
            (kernel.user_module,kernel.user_ns)=kernel.shell.prepare_user_module(user_ns=stepglobals)
        
            # Should we attempt to run the function here?
            
            # (gui, backend) = kernel.shell.enable_matplotlib("qt4") #,import_all=False) # (args.gui, import_all=import_all)
            (gui, backend, clobbered) = kernel.shell.enable_pylab(kernel_gui,import_all=False) # (args.gui, import_all=import_all)

            # kernel.shell.push(stepglobals) # provide globals as variables -- no longer necessary as it's using our namespace already
        
            kernel.shell.push(argkw) # provide arguments as variables
        
            kernel.shell.push({"kernel":kernel},interactive=False) # provide kernel for debugging purposes

            kernel_client = kernel_manager.client()
            kernel_client.start_channels()
            abort_requested_list=[False] # encapsulated in a list to make it mutable

            def stop():
                control.hide()
                kernel_client.stop_channels()
                kernel_manager.shutdown_kernel()
                app.exit()
                pass

            def abort():
                # simple exit doesn't work. See http://stackoverflow.com/questions/1527689/exit-from-ipython
                # too bad this doesn't work right now!!!
                class Quitter(object):
                    def __repr__(self):
                        sys.exit()
                        pass
                    pass
                kernel.shell.push({"quitter":Quitter()})
                kernel.shell.ex("quitter")

                stop()
                abort_requested_list.pop()
                abort_requested_list.append(True)
                pass
        
            if pycode_text is None:            
                sys.stdout.write("\n\nExecute %s/%s\n" % (scripthref.getpath(),runfunc.__name__))
                pass
            else: 
                sys.stdout.write("\n\nExecute %s/%s/%s\n" % (scripthref.getpath(),action,runfunc.__name__))
                pass

            sys.stdout.write("Assign return value to \"ret\" and press Ctrl-D\n")
            sys.stdout.write("Set cont=True to disable interactive mode\n")
            # sys.stdout.write("call abort() to exit\n")

            if LooseVersion(IPython.__version__) >= LooseVersion('4.0.0'):
            # Recent Jupyter/ipython: Import from qtconsole
                from qtconsole.rich_jupyter_widget import RichJupyterWidget as RichIPythonWidget
                pass
            else: 
                from IPython.qt.console.rich_ipython_widget import RichIPythonWidget
                pass
        
            control = RichIPythonWidget()
            control.kernel_manager = kernel_manager
            control.kernel_client = kernel_client
            control.exit_requested.connect(stop)
            control.show()


            #sys.stderr.write("lines=%s\n" % (str(lines)))
            #sys.stderr.write("lines[0]=%s\n" % (str(lines[0])))

        
            try:
                if pycode_text is None:
                    (lines,startinglineno)=inspect.getsourcelines(runfunc)
                
                    assert(lines[0].startswith("def")) # first line of function is the defining line

                    # Preparse to figure out how many lines are part of def
                    preparse=ast.parse("".join(lines),filename=scripthref.getpath(),mode='exec')
                    assert isinstance(preparse.body[0],ast.FunctionDef)
                    assert(preparse.body[0].lineno==1) # Def statement should start on line "1"
                    firstbodyline = preparse.body[0].body[0].lineno
                    lines_to_delete = firstbodyline - 1

                    del lines[:lines_to_delete] # remove def line, leading comments, etc. 
                    lines.insert(0,"    class PTStepReturn(BaseException): pass\n")
                    lines.insert(0,"if 1:\n") # allow function to be indented
                    runfunc_syntaxtree=ast.parse("".join(lines), filename=scripthref.getpath(), mode='exec') # BUG: Should set dont_inherit parameter and properly determine which __future__ import flags should be passed
                    runfunc_syntaxtree=ast.Try(runfunc_syntaxtree.body, [ast.ExceptHandler(ast.Name(id="PTStepReturn", ctx=ast.Load()), [ast.Pass()])])

                    # fixup line numbers
                    for syntreenode in ast.walk(runfunc_syntaxtree):
                        if hasattr(syntreenode,"lineno"):
                            syntreenode.lineno+=startinglineno+lines_to_delete-1-1
                            syntreenode.end_lineno+=startinglineno+lines_to_delete-1-1
                            pass
                        # record calling function node
                        for child in ast.iter_child_nodes(syntreenode):
                            caller = getattr(syntreenode, "caller", syntreenode if isinstance(syntreenode, ast.FunctionDef) else None)
                            if caller is not None:
                                child.caller = caller
                                pass
                            pass
                        pass
                    # runfunc_syntaxtree should consist of the if statement we just added
                    # use _fields attribute to look up fields of an AST element
                    # (e.g. test, body, orelse for IF)
                    # then those fields can be accessed directly
                    assert(len(runfunc_syntaxtree.body)==1)
                    code_container=runfunc_syntaxtree.body[0]
                    assert(isinstance(code_container,ast.If)) # code_container is the if statement we just wrote
                
                    kernel.shell.push({"runfunc_syntaxtree": runfunc_syntaxtree},interactive=False) # provide processed syntax tree for debugging purposes

                    pass
                else : 
                    fullsyntaxtree=ast.parse(pycode_text) # BUG: Should set dont_inherit parameter and properly determine which __future__ import flags should be passed
                    # fixup line numbers
                    for syntreenode in ast.walk(fullsyntaxtree):
                        if hasattr(syntreenode,"lineno"):
                            syntreenode.lineno+=pycode_lineno-1
                            syntreenode.end_lineno+=pycode_lineno-1
                            pass
                        pass
                    code_container=None
                    for codeelement in fullsyntaxtree.body:
                        if isinstance(codeelement,ast.FunctionDef):
                            if codeelement.name==runfunc.__name__:
                                code_container=codeelement
                                runfunc_syntaxtree=codeelement
                                pass
                            pass
                    
                        pass
                    if code_container is None: 
                        raise ValueError("Couldn't find code for %s for ipython execution" % (runfunc.__name__)) 

                    kernel.shell.push({"fullsyntaxtree": fullsyntaxtree},interactive=False) # provide full syntax tree for debugging purposes
                
                    pass

                # identify global variables from runfunc_syntaxtree
                globalvars=set()
                for treeelem in ast.walk(runfunc_syntaxtree):
                    if isinstance(treeelem,ast.Global):
                        globalvars=globalvars.union(treeelem.names)
                        pass
                    pass
            
            
                kernel.shell.push({"abort": abort}) # provide abort function
                kernel.shell.push({"cont": False}) # continue defaults to False
                kernel.shell.push({"__processtrak_interactive":  True })

                class ReplaceReturn(ast.NodeTransformer):

                    def visit_Return(self, node):
                        if not hasattr(node, "caller"):
                            value = node.value if node.value is not None else ast.Dict(keys=[], values=[], lineno=node.lineno, col_offset=node.col_offset)
                            return [
                                ast.copy_location(ast.Assign(targets=[ast.Name(id="ret", ctx=ast.Store(), lineno=node.lineno, col_offset=node.col_offset)], value=value), node),
                                ast.Raise(ast.Name(id="PTStepReturn", ctx=ast.Load(), lineno=node.lineno, col_offset=node.col_offset), lineno=node.lineno, col_offset=node.col_offset)]
                        return node
                    pass
                ReplaceReturn().visit(code_container)

                runfunc_lines=code_container.body

                shell_vars = {"runfunc_lines": runfunc_lines,"scripthref": scripthref}
                if LooseVersion(IPython.__version__) >= LooseVersion('7.0.0'):
                    # provide _ipycompiler for run_ast_nodes
                    import IPython.core.compilerop
                    _ipycompiler = IPython.core.compilerop.CachingCompiler()
                    shell_vars["_ipycompiler"]=_ipycompiler
                    pass
            
                kernel.shell.push(shell_vars,interactive=False) # provide processed syntax tree for debugging purposes
            
                # kernel.shell.run_code(compile("kernel.shell.run_ast_nodes(runfunc_lines,scriptpath,interactivity='all')","None","exec"))
                if LooseVersion(IPython.__version__) >= LooseVersion('4.0.0'):
                    # Recent Jupyter/ipython: Import from qtconsole
                    from qtconsole.inprocess import QtCore
                    pass
                else: 
                    from IPython.qt.inprocess import QtCore
                    pass
                QTimer=QtCore.QTimer

                def showret():
                    control.execute("ret")
                    pass
                
            
                def runcode():
                    if LooseVersion(IPython.__version__) >= LooseVersion('7.0.0'):
                        # IPython 7 and above use async/await
                        control.execute("await kernel.shell.run_ast_nodes(runfunc_lines,scripthref.getpath(),interactivity='none',compiler=_ipycompiler)")
                        pass
                    else:
                        control.execute("kernel.shell.run_ast_nodes(runfunc_lines,scripthref.getpath(),interactivity='none')")
                        pass
                
                    # QTimer.singleShot(25,showret) # get callback 25ms into main loop
                    # showret disabled because it prevents you from running the 
                    # debugger in post-mortem mode to troubleshoot an exception:
                    # import pdb; pdb.pm() 
                    pass
            
                QTimer.singleShot(25,runcode) # get callback 25ms into main loop
                # control.execute("kernel.shell.run_ast_nodes(runfunc_lines,scripthref.getpath(),interactivity='none')")

                pass
            except:
                (exctype, excvalue) = sys.exc_info()[:2] 
                sys.stderr.write("%s while attempting to prepare URL %s code for interactive execution: %s\n" % (exctype.__name__,scripthref.absurl(),str(excvalue)))
                traceback.print_exc()
                raise




            if LooseVersion(IPython.__version__) >= LooseVersion('4.0.0'):
                # Recent Jupyter/ipython: Import from qtconsole
                app.exec_()
                pass
            else:
                # Old ipython
                guisupport.start_event_loop_qt4(app)
                pass
        
            if abort_requested_list[0]:
                pass
        
            if kernel.shell.ev("cont"):
                # cont==True -> disable interactive mode
                ipythonmodelist.pop()
                ipythonmodelist.append(False)
                pass

            try : 
                retval = kernel.shell.ev("ret") # Assign result dictionary to "ret" variable
                pass
            except NameError: # if ret not assigned, return {}
                retval = {}
                pass
        
            # Performing this execution changed values in stepglobals
            # but it should have only done that for variables specified
            # as 'global' in the function.

            # So: Update our backup of the value of stepglobals,
            #     according to the specified globals, and
            #     replace stepglobals with that updated backup

        
            stepglobalsbackup.update(dict([ (varname,stepglobals[varname]) for varname in globalvars]))
            stepglobals.clear()
            stepglobals.update(stepglobalsbackup)

            return retval
        
        finally:
            if 'matplotlib.pyplot' in sys.modules:
                from matplotlib import pyplot as plt
                plt.close('all')
                pass
            pass
        pass
    pass

def resultelementfromdict(output,resultdict):
    # resultdict can either be a dict
    # or a list/tuple of (key,element) pairs. 
    # tuple use case is so that what would otherwise be a key
    # can itself contain a dictionary of attributes

    resultelementdoc=xmldoc.xmldoc.newdoc("resultelement",nsmap=output.nsmap,contexthref=output.getcontexthref())
    
    applyresultdict(resultelementdoc,None,None,resultelementdoc.getroot(),resultdict)
    return resultelementdoc


def applyresultdict_dissectresult(output,element,resultname,resultitem):

    attrdict={}
    if isinstance(resultname,tuple):
        # if result is a tuple, then treat first element 
        # of tuple as actual name, second element as attribute dictionary, 
        assert(len(resultname)==2)
        attrdict.update(resultname[1])
        name=resultname[0]
        pass
    else: 
        name=resultname
        pass
    
    
    # split name by '/' like an xpath... treat all but the trailing
    # part as an xpath context
    if "/" in name: 
        (tagpath,tagname)=name.rsplit("/",1)
        tagpatheval=output.xpathsinglecontext(element,tagpath,namespaces=output.namespaces)
        pass
    else:
        tagname=name
        tagpatheval=element
        pass
    

    if isinstance(resultitem,tuple):
        # if result is a tuple, then treat first element 
        # of tuple as an attribute dictionary, second
        # element as value object
        assert(len(resultitem)==2)
        attrdict.update(resultitem[0])
        resultvalue=resultitem[1]
        pass
    else: 
        resultvalue=resultitem
        pass
    
    
    return (tagname,tagpatheval,attrdict,resultvalue)


def applyresultdict(output,prxdoc,steptag,element,resultdict):
    # resultdict can either be a dict
    # or a list/tuple of (key,element) pairs. 
    # tuple use case is so that what would otherwise be a key
    # can itself contain a dictionary of attributes

    
    if isinstance(resultdict,collections.abc.Mapping):
        # dictionary or dictionary-like: 
        # Convert to list of (key,element) pairs
        resultlist=[ (key,resultdict[key]) for key in resultdict.keys() ]
        pass
    else:
        # list or tuple
        resultlist=resultdict
        pass

    # Go through results...
    for (resultname,resultitem) in resultlist: 

        (tagname,tagpatheval,attrdict,resultvalue)=applyresultdict_dissectresult(output,element,resultname,resultitem)
        
        # ... and remove preexisting elements if present
        # (We do this first because otherwise there is the potential 
        # for provenance mixup between the results we are destroying 
        # and the ones we are about to generated) 
        oldelements=output.children(tagpatheval,tagname,noprovenanceupdate=True)
        for oldelement in oldelements:
            # do the requested attributes match?
            attrmatch=True

            for attrname in attrdict:
                if not(output.hasattr(oldelement,attrname)) or output.getattr(oldelement,attrname)!=attrdict[attrname]:
                    attrmatch=False
                    break
                pass
            
            if attrmatch: 
                # no attribute mismatch... remove element
                output.removeelement(oldelement)
                pass
            pass

        pass

    # Now go through again and generate the elements 
    # Go through results...
    for (resultname,resultitem) in resultlist: 

        (tagname,tagpatheval,attrdict,resultvalue)=applyresultdict_dissectresult(output,element,resultname,resultitem)

        if not ":" in tagname and None in output.nsmap:
            sys.stderr.write("processtrak_procstep.applyresultdict() WARNING: Results from processtrak\nsteps should always specify the XML namespace of result tags\nwhen a default namespace is set. Otherwise they get placed in\nthe default namespace, but not replaced on the next run.\n")
            pass
        
        
        # Create new element according to type
        # sys.stderr.write("resultdict=%s\n" % (str(resultdict))) 
        if isinstance(resultvalue,numbers.Number):
            newel=output.addsimpleelement(tagpatheval,tagname,(resultvalue,))
            pass
        elif isinstance(resultvalue,dcv.value):
            newel=output.addelement(tagpatheval,tagname)
            resultvalue.xmlrepr(output,newel)
            pass
        elif isinstance(resultvalue,basestring):
            newel=output.addelement(tagpatheval,tagname)
            output.settext(newel,resultvalue)
            pass
        elif isinstance(resultvalue,xmldoc.xmldoc):            
            newel=output.addelement(tagpatheval,tagname)
            # copy tree from resultvalue
            resultroot=copy.deepcopy(resultvalue.doc.getroot())
            newel[:]=resultroot[:]
            for attrname in resultroot.attrib:
                newel.attrib[attrname]=resultroot.attrib[attrname]
                pass
            newel.text=resultroot.text
            newel.tail=resultroot.tail

            # mark provenance of sub-elements
            for subel in newel.iterdescendants():
                provenance.elementgenerated(output,subel)
                pass
            pass
        elif isinstance(resultvalue,(list, dict)):
            # create parent element
            newel=output.addelement(tagpatheval,tagname)
            # recurse dictionary value
            applyresultdict(output,prxdoc,steptag,newel,resultvalue)
            pass
        else:
            if prxdoc is not None and steptag is not None:
                raise ValueError("step %s gave unknown result type %s for %s" % (prxdoc.tostring(steptag),unicode(resultvalue.__class__),resultname))
            else: 
                raise ValueError("step gave unknown result type %s for %s" % (unicode(resultvalue.__class__),resultname))
            pass
        # add attributes to newel
        for attrname in attrdict:
            output.setattr(newel,attrname,attrdict[attrname])
            pass

        pass
    pass


def procstep_evalargs(output,prxdoc,prxnsmap,steptag,uniquematches,argnames,argsdefaults,params,inputfilehref,element,paramdebug):
    argkw={}
        
    #sys.stderr.write("argnames=%s\n" % (str(argnames)))
    #sys.stderr.write("params.keys()=%s\n" % (str(params.keys())))
        
    for argname in argnames:
        if paramdebug:
            print("Got parameter %s:" % (argname))
            if argname in argsdefaults:
                print("    Default value: %s" % (argsdefaults[argname]))
                pass
            pass
        # argname often has a underscore-separated type suffix
        if "_" in argname:
            (argnamebase,argnametype)=argname.rsplit("_",1)
            if paramdebug:
                print("    Possibly interpreted as namespace: %s ; name: %s" % (argnamebase,argnametype))
                pass
            pass
        else:
            argnamebase=None
            pass
        
        if argname in params:
            # calling evaluate tracks provenance!
            # returns XML element for auto-params or xpaths
            # returns dc_value for fixed numeric params
            # returns string for fixed string params
            if paramdebug:
                print("    Found parameter %s in step parameters" % (argname))
                pass
            
            argkw[argname]=processtrak_stepparam.evaluate_params(params,argname,None,output,element,inputfilehref,paramdebug)
            pass
        elif argnamebase in params:
            if paramdebug:
                print("    Found parameter %s in step parameters:" % (argnamebase))
                pass
            argkw[argname]=processtrak_stepparam.evaluate_params(params,argnamebase,argnametype,output,element,inputfilehref,paramdebug)
            
        elif argname=="_xmldoc":  # _xmldoc parameter gets output XML document
            if paramdebug:
                print("    Matches _xmldoc: supplying output XML document")
                pass
            argkw[argname]=output         # supply output XML document
            pass
        elif argname=="_prxdoc":  # _xmldoc parameter gets output XML document
            if paramdebug:
                print("    Matches _prxdoc: supplying .prx file")
                pass
            argkw[argname]=prxdoc         # supply .prx file document
            pass
        elif argname=="_step":  # _xmldoc parameter gets output XML document
            if paramdebug:
                print("    Matches _step: supplying .prx step element")
                pass
            argkw[argname]=steptag         # supply output XML document
            pass
        elif argname=="_uniquematches":  # _uniquematches parameter gets list of elements matching the key of the <prx:uniquematch> and corresponding to this particular element
            if paramdebug:
                print("    Matches _uniquematches: supplying uniquematches list")
                pass
            argkw[argname]=uniquematches   # supply uniquematches list
            
            pass
        elif argname=="_inputfilename":  # _inputfilename parameter gets unquoted name (but not path) of input file
            if paramdebug:
                print("    Matches _inputfilename: supplying input file name")
                pass
            argkw[argname]=inputfilehref.get_bare_unquoted_filename()
            pass
        elif argname=="_element" or argname=="_tag": # _element (formerly _tag) parameter gets current tag we are operating on
            if paramdebug:
                print("    Matches _element or _tag: supplying element we are operating on")
                pass
            argkw[argname]=element
            pass
        elif argname=="_dest_href":
            # Get hrefvalue pointing at destination directory, where
            # files should be written
            if paramdebug:
                print("    Matches _dest_href: supplying element href value of dc:summary/dc:dest")
                pass
            destlist=output.xpath("dc:summary/dc:dest",namespaces=processtrak_common.prx_nsmap)
            argkw[argname]=None
            if len(destlist)==1:
                argkw[argname]=dcv.hrefvalue.fromxml(output,destlist[0])
                pass
            pass
        else :
            # Try to extract it from a document tag... ours or cascade down through our ancestors
            if paramdebug:
                print("    Searching through context element and ancestors for value for %s" % (argname))
                pass

            
            testelement = element
            gotvalue = False

            # Iterate through element and ancestors
            while testelement is not None and not(gotvalue):
                try : 
                    argkw[argname]=processtrak_stepparam.findparam(prxnsmap,output,testelement,argname,paramdebug)
                    gotvalue = True
                    pass
                except NameError:
                    pass

                testelement = testelement.getparent()
                pass

            if not gotvalue:
                # Failed to find a value, even after searching
                # through ancestors...
                
                # if there is a default, use that
                if argname in argsdefaults:
                    if paramdebug:
                        print("    Parameter %s not found: using default value" % (argname))
                        pass
                    
                    argkw[argname]=argsdefaults[argname]
                    pass
                else:
                    if paramdebug:
                        print("    Parameter %s not found and no default assigned" % (argname))
                        pass
                    raise NameError("No value found for parameter %s (try enabling --param-debug)" % (argname)) # Let user know we can't find this!
                pass
            pass
        pass
    
    
    return argkw

def procsteppython_runelement(output,prxdoc,prxnsmap,steptag,rootprocesspath,stepprocesspath,elementpath,uniquematches,stepglobals,argnames,argsdefaults,params,inputfilehref,ipythonmodelist,paramdebug,execfunc,action,scripthref,pycode_text,pycode_lineno):
    # *** output should be rwlock'd exactly ONCE when this is called
    # *** Output will be rwlock'd exactly ONCE on return
    #     (but may have been unlocked in the interim)

    element=output.restorepath(elementpath)


    print("Element %s\r" % (dcv.hrefvalue.fromelement(output,element).humanurl()),end="\r")
    #print("Element %s\r" % (canonicalize_path.getelementhumanxpath(output,element,nsmap=prxnsmap)),end="\r")
    sys.stdout.flush()

    rootprocess_el=output.restorepath(rootprocesspath)
    
    provenance.starttrackprovenance()
    try : # try-catch-finally block for starttrackprovenance()
        
        argkw = procstep_evalargs(output,prxdoc,prxnsmap,steptag,uniquematches,argnames,argsdefaults,params,inputfilehref,element,paramdebug)    

        
        
        # unlock XML file if "rununlocked" so parallel processes can mess with it

        #os.chdir(destdir) # CD into destination directory
        try :  # try... catch.. finally.. block for changed directory
            if execfunc.__name__.endswith("unlocked"): 
                if  "_tag" in argnames or "_element" in argnames or "_uniquematches" in argnames:
                    # can't supply element if lock is released
                    raise ValueError("Python function for step %s cannot be rununlocked because it requires XML element parameter(s)" % (processtrak_prxdoc.getstepname(prxdoc,steptag)))
                if uniquematches is not None:
                    # prx:uniquematch not compatible with rununlocked()
                    raise ValueError("<prx:uniquematch> is incompatible with rununlocked() in step %s." % (processtrak_prxdoc.getstepname(prxdoc,steptag)))
                
                output.unlock_rw() # release output lock 
                try: 
                    resultdict=procsteppython_do_run(stepglobals,execfunc,argkw,ipythonmodelist,action,scripthref,pycode_text,pycode_lineno)
                    pass
                finally: 
                    output.lock_rw() # secure output lock ... otherwise
                    # an exception would be handled several levels above
                    # which assumes we are locked. 
                    pass

                del rootprocess_el
                element=output.restorepath(elementpath)
                
                pass
            else: 
                resultdict=procsteppython_do_run(stepglobals,execfunc,argkw,ipythonmodelist,action,scripthref,pycode_text,pycode_lineno)
                # print("processtrak: print_current_used() after do_run of %s" % (str(execfunc)))
                # provenance.print_current_used()
                
            
                output.should_be_rwlocked_once() # Verify that after running, the output is still locked exactly once
                element=output.restorepath(elementpath) # run function may have unlocked output temporarily so we need to restore the element from its path
                pass
            pass
        except: 
            raise
        finally: 
            #os.fchdir(cwd_fd) # CD back to regular directory
            pass
        
        if resultdict is None: 
            resultdict={}  # no results provided
            pass
        

        applyresultdict(output,prxdoc,steptag,element,resultdict)
    
        pass
    except:
        raise
    finally:
        # print("processtrak: print_current_used()")
        # provenance.print_current_used()

        (modified_elements,referenced_elements)=provenance.finishtrackprovenance()
        pass

    # exit with output still in locked state. 
    return (modified_elements,referenced_elements)
    

def procstep_elementmatch_elementpath_generator(prxdoc,output,steptag,elementmatch,elementmatch_nsmap,uniquematchel,filters):
    elmn_copy=copy.copy(elementmatch_nsmap)
    if None in elmn_copy:
        del elmn_copy[None]  # Can not pass None entry
        pass
    # Add filters to elementmatch
    
    if len(filters) > 0:
        elementmatch = "(%s)" % (elementmatch) # so that filter predicate operates on entire set of selected elements, not just on those selected by the last step in the path
        for elementfilter in filters:
            elementmatch+="[%s]" % (elementfilter)
            pass
        pass
    # Search for matching elements

    # sys.stderr.write("elementmatch=%s\n" % (elementmatch))
    try: 
        elements=output.xpath(elementmatch,namespaces=elmn_copy,variables={"filepath":output.filehref.getpath(),"filename":os.path.split(output.filehref.getpath())[1]})
        pass
    except etree.XPathEvalError:
        raise ValueError("XPathEvalError evaluating xpath %s on url %s in step %s" % (elementmatch,output.filehref.absurl(),processtrak_prxdoc.getstepname(prxdoc,steptag)))
    
    elementpaths=[ output.savepath(element) for element in elements]

    for elementpath in elementpaths:
        yield (elementpath,None)  # return element paths one-by-one

    pass

def canonxmlrepr(element):
    """Return copy of element tree and canonicalized 
    string representation"""
    
    elcopy = copy.deepcopy(element)
    provenance.strip_provenance_attributes(elcopy) # Provenance is not part of the canonical representation

    
    et=etree.ElementTree(elcopy)
    fh=BytesIO()
    et.write_c14n(fh,exclusive=True,with_comments=False)
    fh.seek(0)
    canonstr=fh.read().decode('utf-8')
    fh.close()
    return (elcopy,canonstr)

def grandchildren_with_tag(child,tagnames):
    """Return children of child that have tag names in 
    the given set of tag names"""
    ret=[]
    for grandchild in child.iterchildren():
        if grandchild.tag in tagnames:
            ret.append(grandchild)
            pass
        pass
    return ret
    
def procstep_uniquematch_element_generator_nofilters(prxdoc,output,steptag,elementmatch,elementmatch_nsmap,uniquematchel):
    
    # Search for matching elements

    # sys.stderr.write("elementmatch=%s\n" % (elementmatch))
    if not "key" in uniquematchel.attrib:
        raise ValueError("Step %s: <prx:uniquematch> element has no \"key\" attribute" % (processtrak_prxdoc.getstepname(prxdoc,steptag)))
    

    if not "parent" in uniquematchel.attrib:
        raise ValueError("Step %s: <prx:uniquematch> element has no \"parent\" attribute" % (processtrak_prxdoc.getstepname(prxdoc,steptag)))
    

    key_criterion=uniquematchel.attrib["key"]
    parentxpath = uniquematchel.attrib["parent"]

    
    umn_copy=copy.copy(uniquematchel.nsmap)
    if None in umn_copy:
        del umn_copy[None]  # Can not pass None entry
        pass
    
    try: 
        key_elements=output.xpath(key_criterion,namespaces=umn_copy,variables={"filepath":output.filehref.getpath(),"filename":os.path.split(output.filehref.getpath())[1]})
        pass
    except etree.XPathEvalError:
        raise ValueError("XPathEvalError evaluating xpath %s on url %s in step %s" % (key_criterion,output.filehref.absurl(),processtrak_prxdoc.getstepname(prxdoc,steptag)))


    if len(key_elements)==0:
        sys.stderr.write("Warning: step %s: no element match key for <prx:uniquematch> for output href %s\n" % (processtrak_prxdoc.getstepname(prxdoc,steptag),output.get_filehref().absurl()))
        pass
    
    try:
        parent_elements=output.xpath(parentxpath,namespaces=umn_copy,variables={"filepath":output.filehref.getpath(),"filename":os.path.split(output.filehref.getpath())[1]})
        pass
    except etree.XPathEvalError:
        raise ValueError("XPathEvalError evaluating xpath %s on url %s in step %s" % (parentxpath,output.filehref.absurl(),processtrak_prxdoc.getstepname(prxdoc,steptag)))
    
    if len(parent_elements)!=1:
        raise ValueError("Step %s: <prx:uniquematch> parent must match exactly one element (%d found)" % (processtrak_prxdoc.getstepname(prxdoc,steptag),len(parent_elements)))

    grandchild_tagnames=set()
    unique_dict=collections.OrderedDict() # Dictionary by canonical text of element copies
    elementlist_dict={}  # Dictionary by canonical text of list of original elements 
    for element in key_elements:
        # Canonicalize each element by putting it into an element tree
        # and doing canonical serialization
        (elcopy,canonstr)=canonxmlrepr(element)
        if canonstr not in unique_dict:
            unique_dict[canonstr]=elcopy
            elementlist_dict[canonstr]=[]
            pass
        elementlist_dict[canonstr].append(element) # Save original element on list
        grandchild_tagnames.add(elcopy.tag)
        pass



    
    uniquematch_children = prxdoc.xpathcontext(uniquematchel,"*")
    if len(uniquematch_children) != 1:
        raise ValueError("Step %s: <prx:uniquematch> element must have exactly one child (%d found)" % (processtrak_prxdoc.getstepname(prxdoc,steptag),len(uniquematch_children)))
        
    childtag=uniquematch_children[0].tag

    # Find all pre-existing children of the desired parent element
    # that match this tag
    
    candidate_children=[ (child,grandchildren_with_tag(child,grandchild_tagnames)) for child in parent_elements[0].iterchildren() if child.tag==childtag ]

    candidate_grandchildren=[ (child,grandchildren) for (child,grandchildren) in candidate_children if len(grandchildren) > 0 ]

    candidate_children_by_canon_grandchild={ }
    for (child,grandchildren) in candidate_grandchildren:
        for grandchild in grandchildren:
            candidate_children_by_canon_grandchild[canonxmlrepr(grandchild)[1]]=child
            pass
        pass

    # Go through our unique_dict and see if tags already exist
    for canonstr in unique_dict:
        if canonstr in candidate_children_by_canon_grandchild:
            # Use pre-existing element
            yield (candidate_children_by_canon_grandchild[canonstr],elementlist_dict[canonstr])
        else:
            # No such child already exists
            # .. create it
            
            newchild = etree.Element(childtag,nsmap=parent_elements[0].nsmap)

            # ... Give it the characteristic element
            elcopy=unique_dict[canonstr]
            newchild.append(elcopy)

            # Add it to the parent, marking our provenance
            parent_elements[0].append(newchild)
            provenance.elementgenerated(output,elcopy)
            provenance.elementgenerated(output,newchild)
            output.modified=True

            # ... and use it!
            yield (newchild,elementlist_dict[canonstr])
        pass


    pass

def procstep_uniquematch_elementpath_generator(prxdoc,output,steptag,elementmatch,elementmatch_nsmap,uniquematchel,filters):

    matchcriterion="."
    for elementfilter in filters:
        matchcriterion+="[%s]" % (elementfilter)
        pass
    
    
    for (unfiltered,unfiltered_elementmatchlist) in procstep_uniquematch_element_generator_nofilters(prxdoc,output,steptag,elementmatch,elementmatch_nsmap,uniquematchel):
        resultlist = output.xpathcontext(unfiltered,matchcriterion)
        if len(resultlist) > 0:
            assert(len(resultlist)==1) # Shouldn't be possible to get multiple elements
            yield (output.savepath(resultlist[0]),unfiltered_elementmatchlist)
            pass
        
        pass
    pass




def procsteppython_execfunc(scripthref,pycode_text,pycode_lineno,prxdoc,prxnsmap,output,steptag,scripttag,rootprocesspath,stepprocesspath,stepglobals,elementmatch,elementmatch_nsmap,uniquematchel,params,filters,inputfilehref,debugmode,stdouthandler,stderrhandler,ipythonmodelist,paramdebug,execfunc,action):
    
    if hasattr(inspect,"getfullargspec"):
        # python3
        (argnames, varargs, keywords, defaults,kwonlyargs,kwonlydefaults,annotations)=inspect.getfullargspec(execfunc)        
        pass
    else:
        getargspecfunc = inspect.getargspec # python 2
        (argnames, varargs, keywords, defaults)=inspect.getargspec(execfunc)        
        pass
    
    
    argsdefaults={}
    if defaults is not None:
        numdefaults=len(defaults)
        argsdefaults=dict(zip(argnames[-numdefaults:],defaults))
        # argsdefaults is a dictionary by argname of default values.
        pass


    if uniquematchel is not None:
        procstep_elementpath_generator = procstep_uniquematch_elementpath_generator
        pass
    else:
        procstep_elementpath_generator = procstep_elementmatch_elementpath_generator
        pass
    

    # output.unlock_rw() # release output lock

    matchcnt=0


    # Loop over each matching element
    for (elementpath,uniquematches) in procstep_elementpath_generator(prxdoc,output,steptag,elementmatch,elementmatch_nsmap,uniquematchel,filters):
        # elementpath is the path to the element we have found that we are
        # supposed to be operating on
        # uniquematches, if it is not None, and for is a list of elements
        # that matched the key of the <prx:uniquematch> element
        # giving rise to this element. 

        
        matchcnt+=1
        modified_elements=set([])
        referenced_elements=set([])

        el_starttime=timestamp.now().isoformat()
        
        # Capture python stdio/stderr 
        errcapt=StringIO()
        stdouthandler.set_dest(errcapt)
        stderrhandler.set_dest(errcapt)

        status="success"

        output.should_be_rwlocked_once()

        try : 
            (modified_elements,referenced_elements)=procsteppython_runelement(output,prxdoc,prxnsmap,steptag,rootprocesspath,stepprocesspath,elementpath,uniquematches,stepglobals,argnames,argsdefaults,params,inputfilehref,ipythonmodelist,paramdebug,execfunc,action,scripthref,pycode_text,pycode_lineno)
            pass
        except KeyboardInterrupt: 
            # Don't want to hold off keyboard interrupts!

            # sync output... Should be a better way to do this, since it is locked
            output.unlock_rw()
            output.lock_rw()

            raise
        except: 
            (exctype, excvalue) = sys.exc_info()[:2] 
            
            
            sys.stderr.write("%s while processing step %s element on element %s in file %s: %s\n" % (exctype.__name__,action,etxpath2human(elementpath,output.nsmap),output.filehref.getpath(),unicode(excvalue)))
            traceback.print_exc()
            
            status="exception"
            
            # sync output... Should be a better way to do this, since it is locked
            output.unlock_rw()
            output.lock_rw()

            if debugmode and sys.stdin.isatty() and sys.stderr.isatty():
                # automatically start the debugger from an exception in debug mode (if stdin and stderr are ttys) 
                import pdb # Note: Should we consider downloading/installing ipdb (ipython support for pdb)???
                # run debugger in post-mortem mode. 
                pdb.post_mortem()
                pass


            pass

        stdouthandler.set_dest(None)
        stderrhandler.set_dest(None)

        output.should_be_rwlocked_once()

        rootprocess_el=output.restorepath(rootprocesspath)
        # Create lip:process element that contains lip:used tags listing all referenced elements
        element=output.restorepath(elementpath)
        # print "Reference location=%s" % (canonicalize_path.create_canonical_etxpath(output.filename,output.doc,rootprocess_el.getparent()))
        # print "Target location=%s" % (canonicalize_path.create_canonical_etxpath(output.filename,output.doc,element))
        # print "Relative location=%s" % (canonicalize_path.relative_etxpath_to(canonicalize_path.create_canonical_etxpath(output.filename,output.doc,rootprocess_el.getparent()),canonicalize_path.create_canonical_etxpath(output.filename,output.doc,element)))


        process_el=provenance.writeprocessprovenance(output,rootprocesspath,stepprocesspath,referenced_elements)
        
        # !!!*** should add dcp:used tag referencing step definition with 
        # prx file via sha256 hash of i18n canonicalization

        # write timestamps
        provenance.write_timestamp(output,process_el,"lip:starttimestamp",el_starttime)
        provenance.write_timestamp(output,process_el,"lip:finishtimestamp")
        provenance.write_process_info(output,process_el)  # We always write process info to ensure uniqueness of our UUID. It would be better to merge with parent elements before calculating UUID.

        captvalue = errcapt.getvalue()
        
        if bytes is str and isinstance(captvalue,str):
            # In python 2.x captvalue can end up as a str
            # not a unicode. 
            # But we should be writing unicode to the process log
            # ... so we need to decode the utf-8
            captvalue=captvalue.decode('utf-8')
            pass
        

        provenance.write_process_log(output,process_el,status,captvalue)

        target_el=provenance.write_target(output,process_el,dcv.hrefvalue.fromelement(output,element).value())  # lip:target -- target of this particular iteration (ETXPath)

        #if target_el.attrib["{http://www.w3.org/1999/xlink}href"].startswith(".#"):
        #    import pdb
        #    pdb.set_trace()
        #
        #target_hrefc = dcv.hrefvalue.fromelement(output,element).value()
        #    target_context = output.getcontexthref().value()
        #    target_hrefc.attempt_relative_url(target_context)
        #    pass
        
        # Generate uuid
        process_uuid=provenance.set_hash(output,rootprocess_el,process_el)
    
        # Mark all modified elements with our uuid
        provenance.mark_modified_elements(output,modified_elements,process_uuid)

        errcapt.close()
        del errcapt

        output.should_be_rwlocked_once() 


        pass
    
    if matchcnt==0:
        sys.stderr.write("Warning: step %s: no matching elements for output href %s\n" % (processtrak_prxdoc.getstepname(prxdoc,steptag),output.get_filehref().absurl()))
        pass
    

    pass

def procsteppython(scripthref,module_version,pycode_el,prxdoc,output,steptag,scripttag,rootprocesspath,initelementmatch,initelementmatch_nsmap,elementmatch,elementmatch_nsmap,uniquematchel,params,filters,inputfilehref,debugmode,stdouthandler,stderrhandler,ipythonmodelist,paramdebug):
    # *** output should be rwlock'd exactly ONCE when this is called
    # *** Output will be rwlock'd exactly ONCE on return
    #     (but may have been unlocked in the interim)

    prxnsmap=dict(prxdoc.getroot().nsmap)

    action=processtrak_prxdoc.getstepname(prxdoc,steptag)

    stepglobals={}
    stepglobals["__processtrak_stepname"]=action

    # !!!*** NON-REENTRANT
    # Temporarily adjust sys.path so as to add script's directory 
    
    syspath_save=sys.path
    syspath_new=copy.deepcopy(syspath_save)
    syspath_new.insert(0,os.path.split(scripthref.getpath())[0])
    sys.path=syspath_new

    if pycode_el is None: 
        #execfile(scripthref.getpath(),stepglobals)  # load in step
        
        with open(scripthref.getpath()) as f:
            code = compile(f.read(), scripthref.getpath(), 'exec')
            exec(code, stepglobals)
            pass
        
        pycode_text=None
        pycode_lineno=None
        pass
    else: 
        pycode_text=pycode_el.text
        pycode_lineno=pycode_el.sourceline
        # precede code with pycode_lineno blank lines so that parse errors, etc. get the right line number
        #pycode_parsed=ast.parse(("\n"*(pycode_lineno-1))+pycode_text,scriptpath)
        pycode_compiled=compile(("\n"*(pycode_lineno-1))+pycode_text,scripthref.getpath(),"exec")
        exec(pycode_compiled,stepglobals)
        pass
    sys.path=syspath_save
    
    # Find modules imported or referenced
    modules=set()
    for variable in stepglobals:
        if isinstance(stepglobals[variable],sys.__class__) and hasattr(stepglobals[variable],"__name__"):
            # is a module itself
            modulename=stepglobals[variable].__name__
            pass
        elif hasattr(stepglobals[variable],"__module__"):
            modulename=stepglobals[variable].__module__
            pass
        elif hasattr(stepglobals[variable],"__package__"):
            modulename=stepglobals[variable].__package__
            pass
        else: 
            continue
        if modulename is None:
            continue
        #print("modulename=%s" % (modulename))
        modulenamesplit=modulename.split(".")
        for modulenamecomponentcnt in range(len(modulenamesplit)):
            trymodulename=".".join(modulenamesplit[:(modulenamecomponentcnt+1)])
            modules.add(trymodulename)
            pass
        pass
    # *** should Save module.__version__ and other version parameters with provenance!!!

    # create <lip:process> tag for this step 
    
    # output lock should be locked exactly once by caller
    output.should_be_rwlocked_once()
    #output.lock_rw()  # secure output lock

    rootprocess_el=output.restorepath(rootprocesspath)



    stepprocess_el=output.addelement(rootprocess_el,"lip:process")
    provenance.write_timestamp(output,stepprocess_el,"lip:starttimestamp")
    
    provenance.write_action(output,stepprocess_el,action) # action is step name, assigned at top of function
    
    for module in (set(sys.modules.keys()) & modules):  # go through modules
        provenance.reference_pymodule(output,stepprocess_el,"lip:used",rootprocess_el.getparent(),module,warnlevel="none")
        pass
    
    provenance.reference_pt_script(output,stepprocess_el,"lip:used",rootprocess_el.getparent(),scripthref,module_version)
    
    provenance.write_process_info(output,stepprocess_el) # ensure uniqueness prior to uuid generation

    # Generate uuid
    stepprocess_uuid=provenance.set_hash(output,rootprocess_el,stepprocess_el)
    stepprocesspath=output.savepath(stepprocess_el)


    argkw={}

    initfunc=None
    
    # find "init" function or method
    if prxdoc.hasattr(steptag,"initfunction"):
        initfunc=stepglobals[prxdoc.getattr(steptag,"initfunction")]
        pass
    elif "initunlocked" in stepglobals:
        initfunc=stepglobals["initunlocked"]
        pass
    elif "init" in stepglobals : 
        initfunc=stepglobals["init"]
        pass

    if initfunc is not None:
        procsteppython_execfunc(scripthref,pycode_text,pycode_lineno,prxdoc,prxnsmap,output,steptag,scripttag,rootprocesspath,stepprocesspath,stepglobals,initelementmatch,initelementmatch_nsmap,uniquematchel,params,[],inputfilehref,debugmode,stdouthandler,stderrhandler,ipythonmodelist,paramdebug,initfunc,action)
        pass
    
    
    # find "run" function or method
    if prxdoc.hasattr(steptag,"function"):
        runfunc=stepglobals[prxdoc.getattr(steptag,"function")]
        pass
    elif "rununlocked" in stepglobals:
        runfunc=stepglobals["rununlocked"]
        pass
    else : 
        runfunc=stepglobals["run"]
        pass


    procsteppython_execfunc(scripthref,pycode_text,pycode_lineno,prxdoc,prxnsmap,output,steptag,scripttag,rootprocesspath,stepprocesspath,stepglobals,elementmatch,elementmatch_nsmap,uniquematchel,params,filters,inputfilehref,debugmode,stdouthandler,stderrhandler,ipythonmodelist,paramdebug,runfunc,action)

    print("") # add newline

    # output.lock_rw()
    stepprocess_el=output.restorepath(stepprocesspath)
    provenance.write_timestamp(output,stepprocess_el,"lip:finishtimestamp")
    # output.unlock_rw()
    

    pass



def check_inputfilematch(prxdoc,steptag,scripttag,inputfilehref):
    inputfilematch=["*"] # defaults to matching anything

    for inputfilematchel in prxdoc.xpath("prx:inputfilematch") + prxdoc.xpathcontext(steptag,"prx:inputfilematch") + prxdoc.xpathcontext(scripttag,"prx:inputfilematch"):
        if prxdoc.getattr(inputfilematchel,"mode",default="replace")=="union":
            # union
            inputfilematch.append(prxdoc.gettext(inputfilematchel))
            pass
        else:
            # replace
            inputfilematch=[ prxdoc.gettext(inputfilematchel) ]
            pass
        pass
    
    if not any([ fnmatch.fnmatch(inputfilehref.get_bare_unquoted_filename(),inputfilematchstr) for inputfilematchstr in inputfilematch]):
        return False
    
    return True
    

def procstep(prxdoc,out,steptag,filters,overall_starttime,debugmode,stdouthandler,stderrhandler,ipythonmodelist,paramdebug):
    # *** output should be unlocked when this is called

    defaultelementmatch="*" # defaults to all child elements of main tag
    defaultelementmatch_nsmap=None
    try: 
        defaultelementmatchel=prxdoc.xpathsingle("prx:elementmatch")
        defaultelementmatch=defaultelementmatchel.text
        defaultelementmatch_nsmap=defaultelementmatchel.nsmap
        pass
    except NameError:
        pass

    scripttag=prxdoc.xpathsinglecontext(steptag,"prx:script")
    
 
    
    
    elementmatch=defaultelementmatch
    elementmatch_nsmap=defaultelementmatch_nsmap
    # sys.stderr.write("defaultelementmatch=%s\n" % (elementmatch))


    # try for <prx:elementmatch> in <step> 
    try: 
        elementmatchel=prxdoc.xpathsinglecontext(steptag,"prx:elementmatch")
        elementmatch=elementmatchel.text
        # sys.stderr.write("overrideelementmatch=%s\n" % (elementmatch))
        elementmatch_nsmap=elementmatchel.nsmap
        pass
    except NameError:
        pass

    uniquematchel=None
    try:
        uniquematchel=prxdoc.xpathsinglecontext(steptag,"prx:uniquematch")
        pass
    except NameError:
        pass


    ## try for <prx:inputfilematch> in <step> 
    #try: 
    #    inputfilematchel=prxdoc.xpathsinglecontext(steptag,"prx:inputfilematch")
    #inputfilematch=inputfilematchel.text
    #    # sys.stderr.write("overrideinputfilematch=%s\n" % (inputfilematch))
    #    pass
    #except NameError:
    #    pass

    
    # try for <prx:elementmatch> in <script> 
    try: 
        elementmatchel=prxdoc.xpathsinglecontext(scripttag,"prx:elementmatch")
        elementmatch=elementmatchel.text
        # sys.stderr.write("overrideelementmatch=%s\n" % (elementmatch))
        elementmatch_nsmap=elementmatchel.nsmap
        pass
    except NameError:
        pass

    try:
        uniquematchel=prxdoc.xpathsinglecontext(scripttag,"prx:uniquematch")
        pass
    except NameError:
        pass

    if uniquematchel is not None and elementmatch is not defaultelementmatch: 
        raise ValueError("Both prx:uniquematch and prx:element match specified for step %s" % (processtrak_prxdoc.getstepname(prxdoc,steptag)))
    
    
    
    ## try for <prx:inputfilematch> in <script> 
    #try: 
    #    inputfilematchel=prxdoc.xpathsinglecontext(scripttag,"prx:inputfilematch")
    #    inputfilematch=inputfilematchel.text
    #    # sys.stderr.write("overrideinputfilematch=%s\n" % (inputfilematch))
    #    pass
    #except NameError:
    #    pass


    # return if we don't pass filename matching
    if not check_inputfilematch(prxdoc,steptag,scripttag,out.inputfilehref):    
        return
    

    print("\nProcessing step %s on %s->%s" % (processtrak_prxdoc.getstepname(prxdoc,steptag),out.inputfilehref.humanurl(),out.outputfilehref.humanurl()))

    
    
    initelementmatch="/*" # select root element
    initelementmatch_nsmap={}

    try: 
        initelementmatchel=prxdoc.xpathsinglecontext(scripttag,"prx:initelementmatch")
        initelementmatch=initelementmatchel.text
        initelementmatch_nsmap=initelementmatchel.nsmap
        pass
    except NameError:
        pass

                         
    pycode_el=None
    matlabcode_el=None
    comsolmatlabcode_el=None
    module_version = (None,None)
    if prxdoc.hasattr(scripttag,"xlink:href"): 
        #scriptpath=prxdoc.get_href_fullpath(contextnode=scripttag)
        scripthref=dcv.hrefvalue.fromxml(prxdoc,scripttag)
        #scriptpath=scripthref.getpath()
        pass
    elif prxdoc.hasattr(scripttag,"name"): 
        (scripthref,module_version)=find_script_in_path(prxdoc.filehref,prxdoc.getattr(scripttag,"name"))
        pass
    else: 
        pycode_el=prxdoc.child(scripttag,"prx:pycode") # set to pycode tag or None
        matlabcode_el=prxdoc.child(scripttag,"prx:matlabcode") # set to matlabcode tag or None
        comsolmatlabcode_el=prxdoc.child(scripttag,"prx:comsolmatlabcode") # set to comsolmatlabcode tag or None
        scripthref=prxdoc.filehref
        if pycode_el is None and matlabcode_el is None and comsolmatlabcode_el is None: 
            raise ValueError("script %s does not specify cross reference, script name, python code, MATLAB code, or COMSOL MATLAB code" % (prxdoc.tostring(scripttag)))
        pass

    # Build parameter: dictionary by name of lists of stepparam objects
    params={}
    

    for paramel in prxdoc.xpathcontext(steptag,"prx:param|prx:script/prx:param"):
        paramname=prxdoc.getattr(paramel,"name")
        param=processtrak_stepparam.stepparam(name=paramname,prxdoc=prxdoc,element=paramel)

        if not param.name in params:
            params[param.name]=[]
            pass
        params[param.name].append(param)
        
        pass

    processtrak_common.open_or_lock_output(prxdoc,out)
    
    try: 
        out.processpath = processtrak_common.add_process_to_output(prxdoc,out.output,
                                                                   out.inputfilehref,out.outputfilehref,
                                                                   overall_starttime,copyfileinfo=None)
        # procsteppython/procstepmatlab are called with output locked exactly once
        
        if pycode_el is not None or scripthref.get_bare_unquoted_filename().endswith(".py"):
            procsteppython(scripthref,module_version,pycode_el,prxdoc,out.output,steptag,scripttag,out.processpath,initelementmatch,initelementmatch_nsmap,elementmatch,elementmatch_nsmap,uniquematchel,params,filters,out.inputfilehref,debugmode,stdouthandler,stderrhandler,ipythonmodelist,paramdebug)
            pass
        elif comsolmatlabcode_el is not None or scripthref.get_bare_unquoted_filename().endswith("_comsol.m"):
            procstepmatlab(scripthref,comsolmatlabcode_el,prxdoc,out.output,steptag,scripttag,out.processpath,elementmatch,elementmatch_nsmap,uniquematchel,params,filters,out.inputfilehref,debugmode,ipythonmodelist,paramdebug,comsol=True)
            pass
        elif matlabcode_el is not None or scripthref.get_bare_unquoted_filename().endswith(".m"):
            procstepmatlab(scripthref,matlabcode_el,prxdoc,out.output,steptag,scripttag,out.processpath,elementmatch,elementmatch_nsmap,uniquematchel,params,filters,out.inputfilehref,debugmode,ipythonmodelist,paramdebug)
            pass
        pass
    except: 
        raise
    finally: 
        out.output.unlock_rw() # procsteppython/procstepmatlab are called with output locked exactly once
        pass

    pass
