import sys
import os
import os.path
import subprocess
import socket
import urllib
import traceback
import posixpath
import copy

try:
    # py2.x
    from urllib import pathname2url
    from urllib import url2pathname
    from urllib import quote
    from urllib import unquote
    from urlparse import urlsplit
    from urlparse import urlunsplit
    from urlparse import urljoin
    from urlparse import urldefrag
    pass
except ImportError:
    # py3.x
    from urllib.request import pathname2url
    from urllib.request import url2pathname
    from urllib.parse import quote
    from urllib.parse import unquote
    from urllib.parse import urlsplit
    from urllib.parse import urlunsplit
    from urllib.parse import urljoin
    from urllib.parse import urldefrag
    pass

try: 
    import builtins  # python3
    pass
except ImportError: 
    import __builtin__ as builtins # python2
    pass

if not hasattr(builtins,"unicode"):
    # python3
    unicode=str
    pass

if not hasattr(builtins,"basestring"):
    # python3
    basestring=str
    pass



try: 
    from  pkg_resources import resource_string
    from  pkg_resources import iter_entry_points
    pass
except TypeError:
    # work round problem running pychecker
    pass

from . import checklistdb
#from . import canonicalize_path
from . import xmldoc
from . import dc_value


class dummy(object):
    pass
thisdir=os.path.split(sys.modules[dummy.__module__].__file__)[0]



def run_config(href,config_globals):
    # read config file, adding line to change quote characters to [[ ]] 
    configfh=open(href.getpath(),"rb")
    configstr=configfh.read()
    configfh.close()

    code=compile(configstr,href.getpath(),'exec')
    
    exec(code,config_globals,config_globals)

    return configstr


def get_confighrefpaths(primary=False):
    # obtain config path by merging lists generated by limatix.datacollect2.configpath entrypoints.
    # primary=True limits it to just the main /usr/share/limatix/conf or similar
    
    confpath = []
    for entrypoint in iter_entry_points("limatix.datacollect2.config_url_search_path"):
        configpathfunc=entrypoint.load()
        add_to_confpath = configpathfunc()
        if isinstance(add_to_confpath,basestring):
            sys.stderr.write("limatix.dc2_misc: Error enumerating limatix.datacollect2.configurlpath entry points: Got string from %s:%s; expected list or tuple\n" % (entrypoint.module_name,entrypoint.name))
            continue

        if not primary or entrypoint.name=="limatix.share.conf":            
            confpath.extend(add_to_confpath)
            pass
        pass
    
    confhrefpaths=[ dc_value.hrefvalue(confurl) if confurl.endswith(posixpath.sep) else dc_value.hrefvalue(confurl+posixpath.sep) for confurl in confpath ]
    return confhrefpaths
    

def load_config(href,paramdb,iohandlers,createparamserver):

    confhrefpaths=get_confighrefpaths()
    
    
    config_globals={"paramdb":paramdb,"iohandlers":
                    iohandlers,"createparamserver":
                    createparamserver,"_dcchref":href,
                    "_confighrefpaths": confhrefpaths,
                    "_contextstack": [href] }

    def include(includeurl):  # includeurl is a quoted relative or absolute url
        iusplit=urlsplit(includeurl)
        if iusplit.scheme != "" or  posixpath.isabs(iusplit.path) or iusplit.path.startswith("./"):
            # absolute or specific URL
            href=dc_value.hrefvalue(includeurl,contexthref=config_globals["_contextstack"][-1])
            pass
        else:
            # relative URL
            search_href_paths=copy.copy(config_globals["_confighrefpaths"])
            # Prepend current context to search path
            search_href_paths.insert(0,config_globals["_contextstack"][-1])

            # Now search for a match
            matched=False
            for test_href in search_href_paths:
                href=dc_value.hrefvalue(includeurl,contexthref=test_href)
                if os.path.exists(href.getpath()):
                    matched=True
                    break
                pass

            if not(matched):
                raise IOError("Could not find match for include url %s in search path %s" % (includeurl,unicode([ searchhref.humanurl() for searchhref in search_href_paths ])))
            pass
        # Now href is the URL of my include file
        # push to context stack
        config_globals["_contextstack"].append(href)

        # run
        run_config(href,config_globals)

        # pop from context stack        
        config_globals["_contextstack"].pop()        
        pass
    

    config_globals["include"]=include
    
    configtext=run_config(href,config_globals)
    # Now only returns the base config, without substitution from includes
    
    return configtext.decode('utf-8')
    
def set_hostname(paramdb):

    # auto-set hostname
    if paramdb["hostname"].dcvalue.isblank():
        hostname=socket.getfqdn()
        
        # work aroud bug issues in getfqdn()
        if hostname=='localhost' or hostname=='localhost6':
            hostname=None
            pass
        elif hostname.endswith('.localdomain') or hostname.endswith('.localdomain6'):
            hostname=None
            pass
            
            if hostname is None or not '.' in hostname:
                # try running 'hostname --fqdn'
                hostnameproc=subprocess.Popen(['hostname','--fqdn'],stdout=subprocess.PIPE)
                hostnamep=hostnameproc.communicate()[0].strip()
                if hostname is None:
                    hostname=hostnamep
                    pass
                    
            if hostnamep=='localhost' or hostnamep=='localhost6':
                hostnamep=None
                pass
            elif hostnamep.endswith('.localdomain') or hostnamep.endswith('.localdomain6'):
                hostnamep=None
                pass
        
            if hostnamep is not None and not '.' in hostname and '.' in hostnamep:
                hostname=hostnamep
                pass
            pass
        # now have (hopefully robust) fqdn or worst-case bare hostname 
    
        paramdb["hostname"].requestvalstr_sync(hostname)
    
        pass
    pass
        

def searchforchecklist(href):
    # search for in-memory checklist specified by href
    # return (chklistobj,href)
 
    checklists=checklistdb.getchecklists(None,None,None,None,allchecklists=True,allplans=True)

    #sys.stderr.write("dc2_misc/searchforchecklist: Available checklists: %s\n" % (str([checklist.canonicalpath for checklist in checklists])))

    matching=[checklist  for checklist in checklists if checklist.filehref==href]
    # sys.stderr.write("SearchForChecklist: matching=%s\n" % (str(matching)))
    if len(matching) > 1:
        raise ValueError("Multiple in-memory checklists match %s: %s" % (str(href),str(matching)))
    
    if len(matching)==0 or not matching[0].is_open or matching[0].checklist is None:
    #    if fname.startswith("mem://"):
    #        raise ValueError("Attempting to open nonexistent in-memory checklist %s (probably residue of incomplete checklist from previous run)." % (fname))                       
        return (None,href)
    else:
        return (matching[0].checklist,href)
    pass

def chx2chf(parenthref,infilehref,outfilehref):
    # parameters are hrefs


    inxml=xmldoc.xmldoc.loadhref(infilehref)

    inxml.set_href(None)

    # set context to output file directory
    inxml.setcontexthref(outfilehref)
    
    root=inxml.getroot()
    parenttags=inxml.xpath("chx:parent")
    assert(len(parenttags) < 2) # multiple parents does not make sense
    
    if len(parenttags)==1:
        # remove attribute if present
        if inxml.hasattr(parenttags[0],"xlink:href"):
            inxml.remattr(parenttags[0],"xlink:href")
            pass
        parenttag=parenttags[0]
        pass
    else : 
        # no parent tag
        parenttag=inxml.addelement(root,"chx:parent")
        pass

    parenthref.xmlrepr(inxml,parenttag)

    #inxml.setattr(root,"origfilename",origfilename)

    # write output file
    inxml.set_href(outfilehref)
    pass

def stepwidget_update_xml(stepwidget,paramname,newvalue):
    """ Update, add, or remove an XML paramdb2 parameter value 
        within the checklist entry for the checklist step
        used by stepwidget. The parameter database used is
        stepwidget.paramdb and a restorable path is presumed to 
        be in stepwidget.xmlpath. 

        paramname gives the name of the paramdb2 entry to 
        create/update/remove the tag for and newvalue is the
        value to represent. 
        
        If newvalue is blank, then it will remove the tag. """

    gottag=False
    
    if stepwidget.checklist.xmldoc is None:
        try: 
            assert(0)
            pass
        except: 
            # import pdb as pythondb
            # pythondb.post_mortem()
            raise
        pass
    # print "Param Name:  %s" % (paramname)          
        
    # chxstate="checked" in stepwidget.xmltag.attrib and stepwidget.xmltag.attrib["checked"]=="true"
    # if chxstate: 
    #     # once checked, inhibit updates
    #     
    #     pass
    # else : 
    #     # otherwise copy current state into xmltag
    stepwidget.checklist.xmldoc.lock_rw()
    try:
        xmltag=stepwidget.checklist.xmldoc.restorepath(stepwidget.xmlpath)
        if not newvalue.isblank():
            for child in stepwidget.checklist.xmldoc.children(xmltag):
                childtag=stepwidget.checklist.xmldoc.gettag(child)
                if childtag=="dc:"+paramname or childtag==paramname:
                    newvalue.xmlrepr(stepwidget.checklist.xmldoc,child) # ,xml_attribute=xml_attribute)
                    # !!! If we are having trouble with writing absolute hrefs to the checklist file, try uncommenting these
                    #if paramname=="troublesome_parameter":
                    #    sys.stderr.write("dc2_misc: %s %s %s\n" % (str(newvalue.contextlist),str(stepwidget.checklist.xmldoc.filehref.contextlist),stepwidget.checklist.xmldoc.tostring(child)))
                    dc_value.xmlstoredisplayfmt(stepwidget.checklist.xmldoc,child,stepwidget.paramdb[paramname].displayfmt)
                    dc_value.xmlstorevalueclass(stepwidget.checklist.xmldoc,child,stepwidget.paramdb[paramname].paramtype)
                    gottag=True
                    break
                pass
            if not gottag: 
                # need to create tag
                newchild=stepwidget.checklist.xmldoc.addelement(xmltag,"dc:"+paramname)
                newvalue.xmlrepr(stepwidget.checklist.xmldoc,newchild) #xml_attribute=xml_attribute)
                dc_value.xmlstoredisplayfmt(stepwidget.checklist.xmldoc,newchild,stepwidget.paramdb[paramname].displayfmt)
                dc_value.xmlstorevalueclass(stepwidget.checklist.xmldoc,newchild,stepwidget.paramdb[paramname].paramtype)
                # !!! If we are having trouble with writing absolute hrefs to the checklist file, try uncommenting these
                # if paramname=="troublesome":
                #     sys.stderr.write("dc2_misc: %s %s %s\n" % (str(newvalue.contextlist),str(stepwidget.checklist.xmldoc.getcontexthref().contextlist),stepwidget.checklist.xmldoc.tostring(newchild)))
                #     pass
                pass
            pass
        else:
            # newvalue is blank
            # ... remove dc:<paramname> tags from checklist entry
            for child in stepwidget.checklist.xmldoc.children(xmltag):
                childtag=stepwidget.checklist.xmldoc.gettag(child)
                if childtag=="dc:"+paramname or childtag==paramname:
                    stepwidget.checklist.xmldoc.remelement(child)
                    pass
                pass
            
            pass
        pass
    except: 
        raise
    finally:
        stepwidget.checklist.xmldoc.unlock_rw()
        pass
    
    return newvalue

def stepwidget_value_from_xml(stepwidget,paramname):
            
    gotvalue=None
    gotdisplayfmt=None
    # xml_attribute=stepwidget.paramdb[stepwidget.myprops["paramname"]].xml_attribute

    stepwidget.checklist.xmldoc.lock_ro()
    try: 
        xmltag=stepwidget.checklist.xmldoc.restorepath(stepwidget.xmlpath)
        for child in stepwidget.checklist.xmldoc.children(xmltag):
            childtag=stepwidget.checklist.xmldoc.gettag(child)
            if childtag=="dc:"+paramname or childtag==paramname:
                if stepwidget.paramdb is not None:
                    # Use type specified in paramdb if possible
                    paramtype=stepwidget.paramdb[paramname].paramtype
                    pass
                else:
                    # pull type from XML
                    paramtype=dc_value.xmlextractvalueclass(stepwidget.checklist.xmldoc,child)
                    # sys.stderr.write("element %s: paramtype=%s\n" % (etree.tostring(child),str(paramtype)))
                    pass
                if paramtype is not None:
                    gotvalue=paramtype.fromxml(stepwidget.checklist.xmldoc,child)  # xml_attribute=xml_attribute)
                    gotdisplayfmt=dc_value.xmlextractdisplayfmt(stepwidget.checklist.xmldoc,child)
                    pass
                else :
                    gotvalue=dc_value.stringvalue("") # blank
                    gotdisplayfmt=None
                    pass
                break
            pass
        pass
    except: 
        raise
    finally:
        stepwidget.checklist.xmldoc.unlock_ro()
        pass
    return (gotvalue,gotdisplayfmt)
    
